import{P as U,V,n as _,M as L,a as st,b as Ze,Q as bt,B as zt,c as ft,d as vt,E as Jt,e as Je,W as Qe,f as ts,S as es,C as ss,g as is,A as ns,D as os,h as rs,I as as,i as ls,j as cs,G as hs,O as ds,R as ps,k as ie,l as Oe,m as Ne,o as Le,p as He,q as us}from"./VRHostAvatar-CCCp73h2.js";class ys{constructor(){this.container=null,this.roomCodeDisplay=null,this.statusText=null,this.playerList=null,this.onHostGame=null,this.onJoinGame=null,this.onEnterVR=null,this.onHostDashboard=null,this.onJoinAsVR=null,this.createUI()}createUI(){this.container=document.createElement("div"),this.container.id="lobby",this.container.innerHTML=`
      <div class="lobby-panel">
        <h1>VR Sandbox</h1>

        <div class="lobby-section">
          <h2>Host (Dashboard)</h2>
          <button id="host-dashboard-btn" class="btn btn-host">Host Dashboard</button>
        </div>

        <div class="lobby-divider">PLAYERS</div>

        <div class="lobby-section">
          <h2>Join as VR Player</h2>
          <button id="join-vr-btn" class="btn btn-vr">Join as VR</button>
        </div>

        <div class="lobby-section">
          <h2>Join as PC Player</h2>
          <button id="join-btn" class="btn btn-secondary">Join as PC</button>
        </div>

        <div id="status" class="status"></div>

        <div id="player-list" class="player-list" style="display: none;">
          <h3>Players</h3>
          <ul id="players"></ul>
        </div>
      </div>
    `;const t=document.createElement("style");t.textContent=`
      #lobby {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        color: white;
        z-index: 1000;
      }

      .lobby-panel {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 16px;
        padding: 40px;
        min-width: 320px;
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      }

      .lobby-panel h1 {
        margin: 0 0 30px;
        font-size: 28px;
        text-align: center;
      }

      .lobby-panel h2 {
        margin: 0 0 15px;
        font-size: 16px;
        color: #aaa;
      }

      .lobby-section {
        margin-bottom: 20px;
      }

      .lobby-divider {
        text-align: center;
        color: #666;
        margin: 20px 0;
        font-size: 14px;
      }

      .btn {
        width: 100%;
        padding: 14px 20px;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        cursor: pointer;
        transition: all 0.2s;
        margin-bottom: 10px;
      }

      .btn:hover {
        transform: translateY(-2px);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .btn-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      .btn-secondary {
        background: rgba(255, 255, 255, 0.2);
        color: white;
      }

      .btn-vr {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
      }

      .btn-host {
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        color: white;
      }

      .room-code {
        background: rgba(0, 0, 0, 0.3);
        padding: 15px;
        border-radius: 8px;
        text-align: center;
        margin-bottom: 10px;
      }

      .room-code strong {
        display: block;
        font-size: 32px;
        letter-spacing: 6px;
        margin-top: 5px;
        color: #4ade80;
      }

      .status {
        text-align: center;
        padding: 10px;
        color: #fbbf24;
        min-height: 20px;
      }

      .player-list {
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
      }

      .player-list h3 {
        margin: 0 0 10px;
        font-size: 14px;
        color: #aaa;
      }

      .player-list ul {
        list-style: none;
        padding: 0;
        margin: 0;
      }

      .player-list li {
        padding: 8px 12px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        margin-bottom: 5px;
        font-size: 14px;
      }

      #game-hud {
        position: fixed;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 8px;
        color: white;
        font-family: monospace;
        z-index: 100;
      }

      #game-hud .room-info {
        font-size: 12px;
        color: #aaa;
      }

      #game-hud .room-info strong {
        color: #4ade80;
        font-size: 16px;
      }
    `,document.head.appendChild(t),document.body.appendChild(this.container),this.roomCodeDisplay=document.getElementById("room-code-display"),this.statusText=document.getElementById("status"),this.playerList=document.getElementById("player-list"),document.getElementById("host-dashboard-btn").addEventListener("click",()=>{this.onHostDashboard&&this.onHostDashboard()}),document.getElementById("join-vr-btn").addEventListener("click",()=>{this.onJoinAsVR&&this.onJoinAsVR()}),document.getElementById("join-btn").addEventListener("click",()=>{this.onJoinGame&&this.onJoinGame()})}showRoomCode(t){console.log("Room code:",t)}setStatus(t){this.statusText.textContent=t}updatePlayerList(t){const e=document.getElementById("players");e.innerHTML="",t.forEach(s=>{const i=document.createElement("li");i.textContent=`${s.type==="vr"?"ðŸ¥½":"ðŸ–¥ï¸"} ${s.id.substring(0,8)}`,e.appendChild(i)}),this.playerList.style.display=t.length>0?"block":"none"}hide(){this.container.style.display="none"}show(){this.container.style.display="flex"}createGameHUD(t,e){const s=document.createElement("div");return s.id="game-hud",s.innerHTML=`
      <div class="room-info">
        Room: <strong>${t}</strong>
      </div>
      <div id="hud-players">Players: 1</div>
    `,document.body.appendChild(s),s}updateHUDPlayers(t){const e=document.getElementById("hud-players");e&&(e.textContent=`Players: ${t}`)}}class rt{constructor(t){t===void 0&&(t=[0,0,0,0,0,0,0,0,0]),this.elements=t}identity(){const t=this.elements;t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1}setZero(){const t=this.elements;t[0]=0,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t[8]=0}setTrace(t){const e=this.elements;e[0]=t.x,e[4]=t.y,e[8]=t.z}getTrace(t){t===void 0&&(t=new l);const e=this.elements;return t.x=e[0],t.y=e[4],t.z=e[8],t}vmult(t,e){e===void 0&&(e=new l);const s=this.elements,i=t.x,n=t.y,o=t.z;return e.x=s[0]*i+s[1]*n+s[2]*o,e.y=s[3]*i+s[4]*n+s[5]*o,e.z=s[6]*i+s[7]*n+s[8]*o,e}smult(t){for(let e=0;e<this.elements.length;e++)this.elements[e]*=t}mmult(t,e){e===void 0&&(e=new rt);const s=this.elements,i=t.elements,n=e.elements,o=s[0],r=s[1],a=s[2],c=s[3],d=s[4],p=s[5],h=s[6],u=s[7],y=s[8],m=i[0],g=i[1],b=i[2],f=i[3],x=i[4],P=i[5],I=i[6],C=i[7],A=i[8];return n[0]=o*m+r*f+a*I,n[1]=o*g+r*x+a*C,n[2]=o*b+r*P+a*A,n[3]=c*m+d*f+p*I,n[4]=c*g+d*x+p*C,n[5]=c*b+d*P+p*A,n[6]=h*m+u*f+y*I,n[7]=h*g+u*x+y*C,n[8]=h*b+u*P+y*A,e}scale(t,e){e===void 0&&(e=new rt);const s=this.elements,i=e.elements;for(let n=0;n!==3;n++)i[3*n+0]=t.x*s[3*n+0],i[3*n+1]=t.y*s[3*n+1],i[3*n+2]=t.z*s[3*n+2];return e}solve(t,e){e===void 0&&(e=new l);const s=3,i=4,n=[];let o,r;for(o=0;o<s*i;o++)n.push(0);for(o=0;o<3;o++)for(r=0;r<3;r++)n[o+i*r]=this.elements[o+3*r];n[3]=t.x,n[7]=t.y,n[11]=t.z;let a=3;const c=a;let d;const p=4;let h;do{if(o=c-a,n[o+i*o]===0){for(r=o+1;r<c;r++)if(n[o+i*r]!==0){d=p;do h=p-d,n[h+i*o]+=n[h+i*r];while(--d);break}}if(n[o+i*o]!==0)for(r=o+1;r<c;r++){const u=n[o+i*r]/n[o+i*o];d=p;do h=p-d,n[h+i*r]=h<=o?0:n[h+i*r]-n[h+i*o]*u;while(--d)}}while(--a);if(e.z=n[2*i+3]/n[2*i+2],e.y=(n[1*i+3]-n[1*i+2]*e.z)/n[1*i+1],e.x=(n[0*i+3]-n[0*i+2]*e.z-n[0*i+1]*e.y)/n[0*i+0],isNaN(e.x)||isNaN(e.y)||isNaN(e.z)||e.x===1/0||e.y===1/0||e.z===1/0)throw`Could not solve equation! Got x=[${e.toString()}], b=[${t.toString()}], A=[${this.toString()}]`;return e}e(t,e,s){if(s===void 0)return this.elements[e+3*t];this.elements[e+3*t]=s}copy(t){for(let e=0;e<t.elements.length;e++)this.elements[e]=t.elements[e];return this}toString(){let t="";for(let s=0;s<9;s++)t+=this.elements[s]+",";return t}reverse(t){t===void 0&&(t=new rt);const e=3,s=6,i=fs;let n,o;for(n=0;n<3;n++)for(o=0;o<3;o++)i[n+s*o]=this.elements[n+3*o];i[3]=1,i[9]=0,i[15]=0,i[4]=0,i[10]=1,i[16]=0,i[5]=0,i[11]=0,i[17]=1;let r=3;const a=r;let c;const d=s;let p;do{if(n=a-r,i[n+s*n]===0){for(o=n+1;o<a;o++)if(i[n+s*o]!==0){c=d;do p=d-c,i[p+s*n]+=i[p+s*o];while(--c);break}}if(i[n+s*n]!==0)for(o=n+1;o<a;o++){const h=i[n+s*o]/i[n+s*n];c=d;do p=d-c,i[p+s*o]=p<=n?0:i[p+s*o]-i[p+s*n]*h;while(--c)}}while(--r);n=2;do{o=n-1;do{const h=i[n+s*o]/i[n+s*n];c=s;do p=s-c,i[p+s*o]=i[p+s*o]-i[p+s*n]*h;while(--c)}while(o--)}while(--n);n=2;do{const h=1/i[n+s*n];c=s;do p=s-c,i[p+s*n]=i[p+s*n]*h;while(--c)}while(n--);n=2;do{o=2;do{if(p=i[e+o+s*n],isNaN(p)||p===1/0)throw`Could not reverse! A=[${this.toString()}]`;t.e(n,o,p)}while(o--)}while(n--);return t}setRotationFromQuaternion(t){const e=t.x,s=t.y,i=t.z,n=t.w,o=e+e,r=s+s,a=i+i,c=e*o,d=e*r,p=e*a,h=s*r,u=s*a,y=i*a,m=n*o,g=n*r,b=n*a,f=this.elements;return f[0]=1-(h+y),f[1]=d-b,f[2]=p+g,f[3]=d+b,f[4]=1-(c+y),f[5]=u-m,f[6]=p-g,f[7]=u+m,f[8]=1-(c+h),this}transpose(t){t===void 0&&(t=new rt);const e=this.elements,s=t.elements;let i;return s[0]=e[0],s[4]=e[4],s[8]=e[8],i=e[1],s[1]=e[3],s[3]=i,i=e[2],s[2]=e[6],s[6]=i,i=e[5],s[5]=e[7],s[7]=i,t}}const fs=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class l{constructor(t,e,s){t===void 0&&(t=0),e===void 0&&(e=0),s===void 0&&(s=0),this.x=t,this.y=e,this.z=s}cross(t,e){e===void 0&&(e=new l);const s=t.x,i=t.y,n=t.z,o=this.x,r=this.y,a=this.z;return e.x=r*n-a*i,e.y=a*s-o*n,e.z=o*i-r*s,e}set(t,e,s){return this.x=t,this.y=e,this.z=s,this}setZero(){this.x=this.y=this.z=0}vadd(t,e){if(e)e.x=t.x+this.x,e.y=t.y+this.y,e.z=t.z+this.z;else return new l(this.x+t.x,this.y+t.y,this.z+t.z)}vsub(t,e){if(e)e.x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z;else return new l(this.x-t.x,this.y-t.y,this.z-t.z)}crossmat(){return new rt([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const t=this.x,e=this.y,s=this.z,i=Math.sqrt(t*t+e*e+s*s);if(i>0){const n=1/i;this.x*=n,this.y*=n,this.z*=n}else this.x=0,this.y=0,this.z=0;return i}unit(t){t===void 0&&(t=new l);const e=this.x,s=this.y,i=this.z;let n=Math.sqrt(e*e+s*s+i*i);return n>0?(n=1/n,t.x=e*n,t.y=s*n,t.z=i*n):(t.x=1,t.y=0,t.z=0),t}length(){const t=this.x,e=this.y,s=this.z;return Math.sqrt(t*t+e*e+s*s)}lengthSquared(){return this.dot(this)}distanceTo(t){const e=this.x,s=this.y,i=this.z,n=t.x,o=t.y,r=t.z;return Math.sqrt((n-e)*(n-e)+(o-s)*(o-s)+(r-i)*(r-i))}distanceSquared(t){const e=this.x,s=this.y,i=this.z,n=t.x,o=t.y,r=t.z;return(n-e)*(n-e)+(o-s)*(o-s)+(r-i)*(r-i)}scale(t,e){e===void 0&&(e=new l);const s=this.x,i=this.y,n=this.z;return e.x=t*s,e.y=t*i,e.z=t*n,e}vmul(t,e){return e===void 0&&(e=new l),e.x=t.x*this.x,e.y=t.y*this.y,e.z=t.z*this.z,e}addScaledVector(t,e,s){return s===void 0&&(s=new l),s.x=this.x+t*e.x,s.y=this.y+t*e.y,s.z=this.z+t*e.z,s}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}isZero(){return this.x===0&&this.y===0&&this.z===0}negate(t){return t===void 0&&(t=new l),t.x=-this.x,t.y=-this.y,t.z=-this.z,t}tangents(t,e){const s=this.length();if(s>0){const i=ms,n=1/s;i.set(this.x*n,this.y*n,this.z*n);const o=gs;Math.abs(i.x)<.9?(o.set(1,0,0),i.cross(o,t)):(o.set(0,1,0),i.cross(o,t)),i.cross(t,e)}else t.set(1,0,0),e.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}lerp(t,e,s){const i=this.x,n=this.y,o=this.z;s.x=i+(t.x-i)*e,s.y=n+(t.y-n)*e,s.z=o+(t.z-o)*e}almostEquals(t,e){return e===void 0&&(e=1e-6),!(Math.abs(this.x-t.x)>e||Math.abs(this.y-t.y)>e||Math.abs(this.z-t.z)>e)}almostZero(t){return t===void 0&&(t=1e-6),!(Math.abs(this.x)>t||Math.abs(this.y)>t||Math.abs(this.z)>t)}isAntiparallelTo(t,e){return this.negate(ne),ne.almostEquals(t,e)}clone(){return new l(this.x,this.y,this.z)}}l.ZERO=new l(0,0,0);l.UNIT_X=new l(1,0,0);l.UNIT_Y=new l(0,1,0);l.UNIT_Z=new l(0,0,1);const ms=new l,gs=new l,ne=new l;class it{constructor(t){t===void 0&&(t={}),this.lowerBound=new l,this.upperBound=new l,t.lowerBound&&this.lowerBound.copy(t.lowerBound),t.upperBound&&this.upperBound.copy(t.upperBound)}setFromPoints(t,e,s,i){const n=this.lowerBound,o=this.upperBound,r=s;n.copy(t[0]),r&&r.vmult(n,n),o.copy(n);for(let a=1;a<t.length;a++){let c=t[a];r&&(r.vmult(c,oe),c=oe),c.x>o.x&&(o.x=c.x),c.x<n.x&&(n.x=c.x),c.y>o.y&&(o.y=c.y),c.y<n.y&&(n.y=c.y),c.z>o.z&&(o.z=c.z),c.z<n.z&&(n.z=c.z)}return e&&(e.vadd(n,n),e.vadd(o,o)),i&&(n.x-=i,n.y-=i,n.z-=i,o.x+=i,o.y+=i,o.z+=i),this}copy(t){return this.lowerBound.copy(t.lowerBound),this.upperBound.copy(t.upperBound),this}clone(){return new it().copy(this)}extend(t){this.lowerBound.x=Math.min(this.lowerBound.x,t.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,t.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,t.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,t.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,t.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,t.upperBound.z)}overlaps(t){const e=this.lowerBound,s=this.upperBound,i=t.lowerBound,n=t.upperBound,o=i.x<=s.x&&s.x<=n.x||e.x<=n.x&&n.x<=s.x,r=i.y<=s.y&&s.y<=n.y||e.y<=n.y&&n.y<=s.y,a=i.z<=s.z&&s.z<=n.z||e.z<=n.z&&n.z<=s.z;return o&&r&&a}volume(){const t=this.lowerBound,e=this.upperBound;return(e.x-t.x)*(e.y-t.y)*(e.z-t.z)}contains(t){const e=this.lowerBound,s=this.upperBound,i=t.lowerBound,n=t.upperBound;return e.x<=i.x&&s.x>=n.x&&e.y<=i.y&&s.y>=n.y&&e.z<=i.z&&s.z>=n.z}getCorners(t,e,s,i,n,o,r,a){const c=this.lowerBound,d=this.upperBound;t.copy(c),e.set(d.x,c.y,c.z),s.set(d.x,d.y,c.z),i.set(c.x,d.y,d.z),n.set(d.x,c.y,d.z),o.set(c.x,d.y,c.z),r.set(c.x,c.y,d.z),a.copy(d)}toLocalFrame(t,e){const s=re,i=s[0],n=s[1],o=s[2],r=s[3],a=s[4],c=s[5],d=s[6],p=s[7];this.getCorners(i,n,o,r,a,c,d,p);for(let h=0;h!==8;h++){const u=s[h];t.pointToLocal(u,u)}return e.setFromPoints(s)}toWorldFrame(t,e){const s=re,i=s[0],n=s[1],o=s[2],r=s[3],a=s[4],c=s[5],d=s[6],p=s[7];this.getCorners(i,n,o,r,a,c,d,p);for(let h=0;h!==8;h++){const u=s[h];t.pointToWorld(u,u)}return e.setFromPoints(s)}overlapsRay(t){const{direction:e,from:s}=t,i=1/e.x,n=1/e.y,o=1/e.z,r=(this.lowerBound.x-s.x)*i,a=(this.upperBound.x-s.x)*i,c=(this.lowerBound.y-s.y)*n,d=(this.upperBound.y-s.y)*n,p=(this.lowerBound.z-s.z)*o,h=(this.upperBound.z-s.z)*o,u=Math.max(Math.max(Math.min(r,a),Math.min(c,d)),Math.min(p,h)),y=Math.min(Math.min(Math.max(r,a),Math.max(c,d)),Math.max(p,h));return!(y<0||u>y)}}const oe=new l,re=[new l,new l,new l,new l,new l,new l,new l,new l];class ae{constructor(){this.matrix=[]}get(t,e){let{index:s}=t,{index:i}=e;if(i>s){const n=i;i=s,s=n}return this.matrix[(s*(s+1)>>1)+i-1]}set(t,e,s){let{index:i}=t,{index:n}=e;if(n>i){const o=n;n=i,i=o}this.matrix[(i*(i+1)>>1)+n-1]=s?1:0}reset(){for(let t=0,e=this.matrix.length;t!==e;t++)this.matrix[t]=0}setNumObjects(t){this.matrix.length=t*(t-1)>>1}}class ke{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const s=this._listeners;return s[t]===void 0&&(s[t]=[]),s[t].includes(e)||s[t].push(e),this}hasEventListener(t,e){if(this._listeners===void 0)return!1;const s=this._listeners;return!!(s[t]!==void 0&&s[t].includes(e))}hasAnyEventListener(t){return this._listeners===void 0?!1:this._listeners[t]!==void 0}removeEventListener(t,e){if(this._listeners===void 0)return this;const s=this._listeners;if(s[t]===void 0)return this;const i=s[t].indexOf(e);return i!==-1&&s[t].splice(i,1),this}dispatchEvent(t){if(this._listeners===void 0)return this;const s=this._listeners[t.type];if(s!==void 0){t.target=this;for(let i=0,n=s.length;i<n;i++)s[i].call(this,t)}return this}}class K{constructor(t,e,s,i){t===void 0&&(t=0),e===void 0&&(e=0),s===void 0&&(s=0),i===void 0&&(i=1),this.x=t,this.y=e,this.z=s,this.w=i}set(t,e,s,i){return this.x=t,this.y=e,this.z=s,this.w=i,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(t,e){const s=Math.sin(e*.5);return this.x=t.x*s,this.y=t.y*s,this.z=t.z*s,this.w=Math.cos(e*.5),this}toAxisAngle(t){t===void 0&&(t=new l),this.normalize();const e=2*Math.acos(this.w),s=Math.sqrt(1-this.w*this.w);return s<.001?(t.x=this.x,t.y=this.y,t.z=this.z):(t.x=this.x/s,t.y=this.y/s,t.z=this.z/s),[t,e]}setFromVectors(t,e){if(t.isAntiparallelTo(e)){const s=bs,i=vs;t.tangents(s,i),this.setFromAxisAngle(s,Math.PI)}else{const s=t.cross(e);this.x=s.x,this.y=s.y,this.z=s.z,this.w=Math.sqrt(t.length()**2*e.length()**2)+t.dot(e),this.normalize()}return this}mult(t,e){e===void 0&&(e=new K);const s=this.x,i=this.y,n=this.z,o=this.w,r=t.x,a=t.y,c=t.z,d=t.w;return e.x=s*d+o*r+i*c-n*a,e.y=i*d+o*a+n*r-s*c,e.z=n*d+o*c+s*a-i*r,e.w=o*d-s*r-i*a-n*c,e}inverse(t){t===void 0&&(t=new K);const e=this.x,s=this.y,i=this.z,n=this.w;this.conjugate(t);const o=1/(e*e+s*s+i*i+n*n);return t.x*=o,t.y*=o,t.z*=o,t.w*=o,t}conjugate(t){return t===void 0&&(t=new K),t.x=-this.x,t.y=-this.y,t.z=-this.z,t.w=this.w,t}normalize(){let t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return t===0?(this.x=0,this.y=0,this.z=0,this.w=0):(t=1/t,this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}normalizeFast(){const t=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return t===0?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}vmult(t,e){e===void 0&&(e=new l);const s=t.x,i=t.y,n=t.z,o=this.x,r=this.y,a=this.z,c=this.w,d=c*s+r*n-a*i,p=c*i+a*s-o*n,h=c*n+o*i-r*s,u=-o*s-r*i-a*n;return e.x=d*c+u*-o+p*-a-h*-r,e.y=p*c+u*-r+h*-o-d*-a,e.z=h*c+u*-a+d*-r-p*-o,e}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}toEuler(t,e){e===void 0&&(e="YZX");let s,i,n;const o=this.x,r=this.y,a=this.z,c=this.w;switch(e){case"YZX":const d=o*r+a*c;if(d>.499&&(s=2*Math.atan2(o,c),i=Math.PI/2,n=0),d<-.499&&(s=-2*Math.atan2(o,c),i=-Math.PI/2,n=0),s===void 0){const p=o*o,h=r*r,u=a*a;s=Math.atan2(2*r*c-2*o*a,1-2*h-2*u),i=Math.asin(2*d),n=Math.atan2(2*o*c-2*r*a,1-2*p-2*u)}break;default:throw new Error(`Euler order ${e} not supported yet.`)}t.y=s,t.z=i,t.x=n}setFromEuler(t,e,s,i){i===void 0&&(i="XYZ");const n=Math.cos(t/2),o=Math.cos(e/2),r=Math.cos(s/2),a=Math.sin(t/2),c=Math.sin(e/2),d=Math.sin(s/2);return i==="XYZ"?(this.x=a*o*r+n*c*d,this.y=n*c*r-a*o*d,this.z=n*o*d+a*c*r,this.w=n*o*r-a*c*d):i==="YXZ"?(this.x=a*o*r+n*c*d,this.y=n*c*r-a*o*d,this.z=n*o*d-a*c*r,this.w=n*o*r+a*c*d):i==="ZXY"?(this.x=a*o*r-n*c*d,this.y=n*c*r+a*o*d,this.z=n*o*d+a*c*r,this.w=n*o*r-a*c*d):i==="ZYX"?(this.x=a*o*r-n*c*d,this.y=n*c*r+a*o*d,this.z=n*o*d-a*c*r,this.w=n*o*r+a*c*d):i==="YZX"?(this.x=a*o*r+n*c*d,this.y=n*c*r+a*o*d,this.z=n*o*d-a*c*r,this.w=n*o*r-a*c*d):i==="XZY"&&(this.x=a*o*r-n*c*d,this.y=n*c*r-a*o*d,this.z=n*o*d+a*c*r,this.w=n*o*r+a*c*d),this}clone(){return new K(this.x,this.y,this.z,this.w)}slerp(t,e,s){s===void 0&&(s=new K);const i=this.x,n=this.y,o=this.z,r=this.w;let a=t.x,c=t.y,d=t.z,p=t.w,h,u,y,m,g;return u=i*a+n*c+o*d+r*p,u<0&&(u=-u,a=-a,c=-c,d=-d,p=-p),1-u>1e-6?(h=Math.acos(u),y=Math.sin(h),m=Math.sin((1-e)*h)/y,g=Math.sin(e*h)/y):(m=1-e,g=e),s.x=m*i+g*a,s.y=m*n+g*c,s.z=m*o+g*d,s.w=m*r+g*p,s}integrate(t,e,s,i){i===void 0&&(i=new K);const n=t.x*s.x,o=t.y*s.y,r=t.z*s.z,a=this.x,c=this.y,d=this.z,p=this.w,h=e*.5;return i.x+=h*(n*p+o*d-r*c),i.y+=h*(o*p+r*a-n*d),i.z+=h*(r*p+n*c-o*a),i.w+=h*(-n*a-o*c-r*d),i}}const bs=new l,vs=new l,ws={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class B{constructor(t){t===void 0&&(t={}),this.id=B.idCounter++,this.type=t.type||0,this.boundingSphereRadius=0,this.collisionResponse=t.collisionResponse?t.collisionResponse:!0,this.collisionFilterGroup=t.collisionFilterGroup!==void 0?t.collisionFilterGroup:1,this.collisionFilterMask=t.collisionFilterMask!==void 0?t.collisionFilterMask:-1,this.material=t.material?t.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(t,e){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(t,e,s,i){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}B.idCounter=0;B.types=ws;class G{constructor(t){t===void 0&&(t={}),this.position=new l,this.quaternion=new K,t.position&&this.position.copy(t.position),t.quaternion&&this.quaternion.copy(t.quaternion)}pointToLocal(t,e){return G.pointToLocalFrame(this.position,this.quaternion,t,e)}pointToWorld(t,e){return G.pointToWorldFrame(this.position,this.quaternion,t,e)}vectorToWorldFrame(t,e){return e===void 0&&(e=new l),this.quaternion.vmult(t,e),e}static pointToLocalFrame(t,e,s,i){return i===void 0&&(i=new l),s.vsub(t,i),e.conjugate(le),le.vmult(i,i),i}static pointToWorldFrame(t,e,s,i){return i===void 0&&(i=new l),e.vmult(s,i),i.vadd(t,i),i}static vectorToWorldFrame(t,e,s){return s===void 0&&(s=new l),t.vmult(e,s),s}static vectorToLocalFrame(t,e,s,i){return i===void 0&&(i=new l),e.w*=-1,e.vmult(s,i),e.w*=-1,i}}const le=new K;class Tt extends B{constructor(t){t===void 0&&(t={});const{vertices:e=[],faces:s=[],normals:i=[],axes:n,boundingSphereRadius:o}=t;super({type:B.types.CONVEXPOLYHEDRON}),this.vertices=e,this.faces=s,this.faceNormals=i,this.faceNormals.length===0&&this.computeNormals(),o?this.boundingSphereRadius=o:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=n?n.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const t=this.faces,e=this.vertices,s=this.uniqueEdges;s.length=0;const i=new l;for(let n=0;n!==t.length;n++){const o=t[n],r=o.length;for(let a=0;a!==r;a++){const c=(a+1)%r;e[o[a]].vsub(e[o[c]],i),i.normalize();let d=!1;for(let p=0;p!==s.length;p++)if(s[p].almostEquals(i)||s[p].almostEquals(i)){d=!0;break}d||s.push(i.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let t=0;t<this.faces.length;t++){for(let i=0;i<this.faces[t].length;i++)if(!this.vertices[this.faces[t][i]])throw new Error(`Vertex ${this.faces[t][i]} not found!`);const e=this.faceNormals[t]||new l;this.getFaceNormal(t,e),e.negate(e),this.faceNormals[t]=e;const s=this.vertices[this.faces[t][0]];if(e.dot(s)<0){console.error(`.faceNormals[${t}] = Vec3(${e.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let i=0;i<this.faces[t].length;i++)console.warn(`.vertices[${this.faces[t][i]}] = Vec3(${this.vertices[this.faces[t][i]].toString()})`)}}}getFaceNormal(t,e){const s=this.faces[t],i=this.vertices[s[0]],n=this.vertices[s[1]],o=this.vertices[s[2]];Tt.computeNormal(i,n,o,e)}static computeNormal(t,e,s,i){const n=new l,o=new l;e.vsub(t,o),s.vsub(e,n),n.cross(o,i),i.isZero()||i.normalize()}clipAgainstHull(t,e,s,i,n,o,r,a,c){const d=new l;let p=-1,h=-Number.MAX_VALUE;for(let y=0;y<s.faces.length;y++){d.copy(s.faceNormals[y]),n.vmult(d,d);const m=d.dot(o);m>h&&(h=m,p=y)}const u=[];for(let y=0;y<s.faces[p].length;y++){const m=s.vertices[s.faces[p][y]],g=new l;g.copy(m),n.vmult(g,g),i.vadd(g,g),u.push(g)}p>=0&&this.clipFaceAgainstHull(o,t,e,u,r,a,c)}findSeparatingAxis(t,e,s,i,n,o,r,a){const c=new l,d=new l,p=new l,h=new l,u=new l,y=new l;let m=Number.MAX_VALUE;const g=this;if(g.uniqueAxes)for(let b=0;b!==g.uniqueAxes.length;b++){s.vmult(g.uniqueAxes[b],c);const f=g.testSepAxis(c,t,e,s,i,n);if(f===!1)return!1;f<m&&(m=f,o.copy(c))}else{const b=r?r.length:g.faces.length;for(let f=0;f<b;f++){const x=r?r[f]:f;c.copy(g.faceNormals[x]),s.vmult(c,c);const P=g.testSepAxis(c,t,e,s,i,n);if(P===!1)return!1;P<m&&(m=P,o.copy(c))}}if(t.uniqueAxes)for(let b=0;b!==t.uniqueAxes.length;b++){n.vmult(t.uniqueAxes[b],d);const f=g.testSepAxis(d,t,e,s,i,n);if(f===!1)return!1;f<m&&(m=f,o.copy(d))}else{const b=a?a.length:t.faces.length;for(let f=0;f<b;f++){const x=a?a[f]:f;d.copy(t.faceNormals[x]),n.vmult(d,d);const P=g.testSepAxis(d,t,e,s,i,n);if(P===!1)return!1;P<m&&(m=P,o.copy(d))}}for(let b=0;b!==g.uniqueEdges.length;b++){s.vmult(g.uniqueEdges[b],h);for(let f=0;f!==t.uniqueEdges.length;f++)if(n.vmult(t.uniqueEdges[f],u),h.cross(u,y),!y.almostZero()){y.normalize();const x=g.testSepAxis(y,t,e,s,i,n);if(x===!1)return!1;x<m&&(m=x,o.copy(y))}}return i.vsub(e,p),p.dot(o)>0&&o.negate(o),!0}testSepAxis(t,e,s,i,n,o){const r=this;Tt.project(r,t,s,i,Wt),Tt.project(e,t,n,o,$t);const a=Wt[0],c=Wt[1],d=$t[0],p=$t[1];if(a<p||d<c)return!1;const h=a-p,u=d-c;return h<u?h:u}calculateLocalInertia(t,e){const s=new l,i=new l;this.computeLocalAABB(i,s);const n=s.x-i.x,o=s.y-i.y,r=s.z-i.z;e.x=1/12*t*(2*o*2*o+2*r*2*r),e.y=1/12*t*(2*n*2*n+2*r*2*r),e.z=1/12*t*(2*o*2*o+2*n*2*n)}getPlaneConstantOfFace(t){const e=this.faces[t],s=this.faceNormals[t],i=this.vertices[e[0]];return-s.dot(i)}clipFaceAgainstHull(t,e,s,i,n,o,r){const a=new l,c=new l,d=new l,p=new l,h=new l,u=new l,y=new l,m=new l,g=this,b=[],f=i,x=b;let P=-1,I=Number.MAX_VALUE;for(let T=0;T<g.faces.length;T++){a.copy(g.faceNormals[T]),s.vmult(a,a);const H=a.dot(t);H<I&&(I=H,P=T)}if(P<0)return;const C=g.faces[P];C.connectedFaces=[];for(let T=0;T<g.faces.length;T++)for(let H=0;H<g.faces[T].length;H++)C.indexOf(g.faces[T][H])!==-1&&T!==P&&C.connectedFaces.indexOf(T)===-1&&C.connectedFaces.push(T);const A=C.length;for(let T=0;T<A;T++){const H=g.vertices[C[T]],F=g.vertices[C[(T+1)%A]];H.vsub(F,c),d.copy(c),s.vmult(d,d),e.vadd(d,d),p.copy(this.faceNormals[P]),s.vmult(p,p),e.vadd(p,p),d.cross(p,h),h.negate(h),u.copy(H),s.vmult(u,u),e.vadd(u,u);const E=C.connectedFaces[T];y.copy(this.faceNormals[E]);const M=this.getPlaneConstantOfFace(E);m.copy(y),s.vmult(m,m);const z=M-m.dot(e);for(this.clipFaceAgainstPlane(f,x,m,z);f.length;)f.shift();for(;x.length;)f.push(x.shift())}y.copy(this.faceNormals[P]);const O=this.getPlaneConstantOfFace(P);m.copy(y),s.vmult(m,m);const k=O-m.dot(e);for(let T=0;T<f.length;T++){let H=m.dot(f[T])+k;if(H<=n&&(console.log(`clamped: depth=${H} to minDist=${n}`),H=n),H<=o){const F=f[T];if(H<=1e-6){const E={point:F,normal:m,depth:H};r.push(E)}}}}clipFaceAgainstPlane(t,e,s,i){let n,o;const r=t.length;if(r<2)return e;let a=t[t.length-1],c=t[0];n=s.dot(a)+i;for(let d=0;d<r;d++){if(c=t[d],o=s.dot(c)+i,n<0)if(o<0){const p=new l;p.copy(c),e.push(p)}else{const p=new l;a.lerp(c,n/(n-o),p),e.push(p)}else if(o<0){const p=new l;a.lerp(c,n/(n-o),p),e.push(p),e.push(c)}a=c,n=o}return e}computeWorldVertices(t,e){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new l);const s=this.vertices,i=this.worldVertices;for(let n=0;n!==this.vertices.length;n++)e.vmult(s[n],i[n]),t.vadd(i[n],i[n]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(t,e){const s=this.vertices;t.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),e.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let i=0;i<this.vertices.length;i++){const n=s[i];n.x<t.x?t.x=n.x:n.x>e.x&&(e.x=n.x),n.y<t.y?t.y=n.y:n.y>e.y&&(e.y=n.y),n.z<t.z?t.z=n.z:n.z>e.z&&(e.z=n.z)}}computeWorldFaceNormals(t){const e=this.faceNormals.length;for(;this.worldFaceNormals.length<e;)this.worldFaceNormals.push(new l);const s=this.faceNormals,i=this.worldFaceNormals;for(let n=0;n!==e;n++)t.vmult(s[n],i[n]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let t=0;const e=this.vertices;for(let s=0;s!==e.length;s++){const i=e[s].lengthSquared();i>t&&(t=i)}this.boundingSphereRadius=Math.sqrt(t)}calculateWorldAABB(t,e,s,i){const n=this.vertices;let o,r,a,c,d,p,h=new l;for(let u=0;u<n.length;u++){h.copy(n[u]),e.vmult(h,h),t.vadd(h,h);const y=h;(o===void 0||y.x<o)&&(o=y.x),(c===void 0||y.x>c)&&(c=y.x),(r===void 0||y.y<r)&&(r=y.y),(d===void 0||y.y>d)&&(d=y.y),(a===void 0||y.z<a)&&(a=y.z),(p===void 0||y.z>p)&&(p=y.z)}s.set(o,r,a),i.set(c,d,p)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(t){t===void 0&&(t=new l);const e=this.vertices;for(let s=0;s<e.length;s++)t.vadd(e[s],t);return t.scale(1/e.length,t),t}transformAllPoints(t,e){const s=this.vertices.length,i=this.vertices;if(e){for(let n=0;n<s;n++){const o=i[n];e.vmult(o,o)}for(let n=0;n<this.faceNormals.length;n++){const o=this.faceNormals[n];e.vmult(o,o)}}if(t)for(let n=0;n<s;n++){const o=i[n];o.vadd(t,o)}}pointIsInside(t){const e=this.vertices,s=this.faces,i=this.faceNormals,n=new l;this.getAveragePointLocal(n);for(let o=0;o<this.faces.length;o++){let r=i[o];const a=e[s[o][0]],c=new l;t.vsub(a,c);const d=r.dot(c),p=new l;n.vsub(a,p);const h=r.dot(p);if(d<0&&h>0||d>0&&h<0)return!1}return-1}static project(t,e,s,i,n){const o=t.vertices.length,r=xs;let a=0,c=0;const d=Ps,p=t.vertices;d.setZero(),G.vectorToLocalFrame(s,i,e,r),G.pointToLocalFrame(s,i,d,d);const h=d.dot(r);c=a=p[0].dot(r);for(let u=1;u<o;u++){const y=p[u].dot(r);y>a&&(a=y),y<c&&(c=y)}if(c-=h,a-=h,c>a){const u=c;c=a,a=u}n[0]=a,n[1]=c}}const Wt=[],$t=[];new l;const xs=new l,Ps=new l;class Ot extends B{constructor(t){super({type:B.types.BOX}),this.halfExtents=t,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const t=this.halfExtents.x,e=this.halfExtents.y,s=this.halfExtents.z,i=l,n=[new i(-t,-e,-s),new i(t,-e,-s),new i(t,e,-s),new i(-t,e,-s),new i(-t,-e,s),new i(t,-e,s),new i(t,e,s),new i(-t,e,s)],o=[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],r=[new i(0,0,1),new i(0,1,0),new i(1,0,0)],a=new Tt({vertices:n,faces:o,axes:r});this.convexPolyhedronRepresentation=a,a.material=this.material}calculateLocalInertia(t,e){return e===void 0&&(e=new l),Ot.calculateInertia(this.halfExtents,t,e),e}static calculateInertia(t,e,s){const i=t;s.x=1/12*e*(2*i.y*2*i.y+2*i.z*2*i.z),s.y=1/12*e*(2*i.x*2*i.x+2*i.z*2*i.z),s.z=1/12*e*(2*i.y*2*i.y+2*i.x*2*i.x)}getSideNormals(t,e){const s=t,i=this.halfExtents;if(s[0].set(i.x,0,0),s[1].set(0,i.y,0),s[2].set(0,0,i.z),s[3].set(-i.x,0,0),s[4].set(0,-i.y,0),s[5].set(0,0,-i.z),e!==void 0)for(let n=0;n!==s.length;n++)e.vmult(s[n],s[n]);return s}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(t,e,s){const i=this.halfExtents,n=[[i.x,i.y,i.z],[-i.x,i.y,i.z],[-i.x,-i.y,i.z],[-i.x,-i.y,-i.z],[i.x,-i.y,-i.z],[i.x,i.y,-i.z],[-i.x,i.y,-i.z],[i.x,-i.y,i.z]];for(let o=0;o<n.length;o++)mt.set(n[o][0],n[o][1],n[o][2]),e.vmult(mt,mt),t.vadd(mt,mt),s(mt.x,mt.y,mt.z)}calculateWorldAABB(t,e,s,i){const n=this.halfExtents;at[0].set(n.x,n.y,n.z),at[1].set(-n.x,n.y,n.z),at[2].set(-n.x,-n.y,n.z),at[3].set(-n.x,-n.y,-n.z),at[4].set(n.x,-n.y,-n.z),at[5].set(n.x,n.y,-n.z),at[6].set(-n.x,n.y,-n.z),at[7].set(n.x,-n.y,n.z);const o=at[0];e.vmult(o,o),t.vadd(o,o),i.copy(o),s.copy(o);for(let r=1;r<8;r++){const a=at[r];e.vmult(a,a),t.vadd(a,a);const c=a.x,d=a.y,p=a.z;c>i.x&&(i.x=c),d>i.y&&(i.y=d),p>i.z&&(i.z=p),c<s.x&&(s.x=c),d<s.y&&(s.y=d),p<s.z&&(s.z=p)}}}const mt=new l,at=[new l,new l,new l,new l,new l,new l,new l,new l],Qt={DYNAMIC:1,STATIC:2,KINEMATIC:4},te={AWAKE:0,SLEEPY:1,SLEEPING:2};class S extends ke{constructor(t){t===void 0&&(t={}),super(),this.id=S.idCounter++,this.index=-1,this.world=null,this.vlambda=new l,this.collisionFilterGroup=typeof t.collisionFilterGroup=="number"?t.collisionFilterGroup:1,this.collisionFilterMask=typeof t.collisionFilterMask=="number"?t.collisionFilterMask:-1,this.collisionResponse=typeof t.collisionResponse=="boolean"?t.collisionResponse:!0,this.position=new l,this.previousPosition=new l,this.interpolatedPosition=new l,this.initPosition=new l,t.position&&(this.position.copy(t.position),this.previousPosition.copy(t.position),this.interpolatedPosition.copy(t.position),this.initPosition.copy(t.position)),this.velocity=new l,t.velocity&&this.velocity.copy(t.velocity),this.initVelocity=new l,this.force=new l;const e=typeof t.mass=="number"?t.mass:0;this.mass=e,this.invMass=e>0?1/e:0,this.material=t.material||null,this.linearDamping=typeof t.linearDamping=="number"?t.linearDamping:.01,this.type=e<=0?S.STATIC:S.DYNAMIC,typeof t.type==typeof S.STATIC&&(this.type=t.type),this.allowSleep=typeof t.allowSleep<"u"?t.allowSleep:!0,this.sleepState=S.AWAKE,this.sleepSpeedLimit=typeof t.sleepSpeedLimit<"u"?t.sleepSpeedLimit:.1,this.sleepTimeLimit=typeof t.sleepTimeLimit<"u"?t.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new l,this.quaternion=new K,this.initQuaternion=new K,this.previousQuaternion=new K,this.interpolatedQuaternion=new K,t.quaternion&&(this.quaternion.copy(t.quaternion),this.initQuaternion.copy(t.quaternion),this.previousQuaternion.copy(t.quaternion),this.interpolatedQuaternion.copy(t.quaternion)),this.angularVelocity=new l,t.angularVelocity&&this.angularVelocity.copy(t.angularVelocity),this.initAngularVelocity=new l,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new l,this.invInertia=new l,this.invInertiaWorld=new rt,this.invMassSolve=0,this.invInertiaSolve=new l,this.invInertiaWorldSolve=new rt,this.fixedRotation=typeof t.fixedRotation<"u"?t.fixedRotation:!1,this.angularDamping=typeof t.angularDamping<"u"?t.angularDamping:.01,this.linearFactor=new l(1,1,1),t.linearFactor&&this.linearFactor.copy(t.linearFactor),this.angularFactor=new l(1,1,1),t.angularFactor&&this.angularFactor.copy(t.angularFactor),this.aabb=new it,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new l,this.isTrigger=!!t.isTrigger,t.shape&&this.addShape(t.shape),this.updateMassProperties()}wakeUp(){const t=this.sleepState;this.sleepState=S.AWAKE,this.wakeUpAfterNarrowphase=!1,t===S.SLEEPING&&this.dispatchEvent(S.wakeupEvent)}sleep(){this.sleepState=S.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(t){if(this.allowSleep){const e=this.sleepState,s=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),i=this.sleepSpeedLimit**2;e===S.AWAKE&&s<i?(this.sleepState=S.SLEEPY,this.timeLastSleepy=t,this.dispatchEvent(S.sleepyEvent)):e===S.SLEEPY&&s>i?this.wakeUp():e===S.SLEEPY&&t-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(S.sleepEvent))}}updateSolveMassProperties(){this.sleepState===S.SLEEPING||this.type===S.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(t,e){return e===void 0&&(e=new l),t.vsub(this.position,e),this.quaternion.conjugate().vmult(e,e),e}vectorToLocalFrame(t,e){return e===void 0&&(e=new l),this.quaternion.conjugate().vmult(t,e),e}pointToWorldFrame(t,e){return e===void 0&&(e=new l),this.quaternion.vmult(t,e),e.vadd(this.position,e),e}vectorToWorldFrame(t,e){return e===void 0&&(e=new l),this.quaternion.vmult(t,e),e}addShape(t,e,s){const i=new l,n=new K;return e&&i.copy(e),s&&n.copy(s),this.shapes.push(t),this.shapeOffsets.push(i),this.shapeOrientations.push(n),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=this,this}removeShape(t){const e=this.shapes.indexOf(t);return e===-1?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(e,1),this.shapeOffsets.splice(e,1),this.shapeOrientations.splice(e,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=null,this)}updateBoundingRadius(){const t=this.shapes,e=this.shapeOffsets,s=t.length;let i=0;for(let n=0;n!==s;n++){const o=t[n];o.updateBoundingSphereRadius();const r=e[n].length(),a=o.boundingSphereRadius;r+a>i&&(i=r+a)}this.boundingRadius=i}updateAABB(){const t=this.shapes,e=this.shapeOffsets,s=this.shapeOrientations,i=t.length,n=Es,o=Is,r=this.quaternion,a=this.aabb,c=Rs;for(let d=0;d!==i;d++){const p=t[d];r.vmult(e[d],n),n.vadd(this.position,n),r.mult(s[d],o),p.calculateWorldAABB(n,o,c.lowerBound,c.upperBound),d===0?a.copy(c):a.extend(c)}this.aabbNeedsUpdate=!1}updateInertiaWorld(t){const e=this.invInertia;if(!(e.x===e.y&&e.y===e.z&&!t)){const s=Cs,i=Ss;s.setRotationFromQuaternion(this.quaternion),s.transpose(i),s.scale(e,s),s.mmult(i,this.invInertiaWorld)}}applyForce(t,e){if(e===void 0&&(e=new l),this.type!==S.DYNAMIC)return;this.sleepState===S.SLEEPING&&this.wakeUp();const s=zs;e.cross(t,s),this.force.vadd(t,this.force),this.torque.vadd(s,this.torque)}applyLocalForce(t,e){if(e===void 0&&(e=new l),this.type!==S.DYNAMIC)return;const s=Ms,i=Bs;this.vectorToWorldFrame(t,s),this.vectorToWorldFrame(e,i),this.applyForce(s,i)}applyTorque(t){this.type===S.DYNAMIC&&(this.sleepState===S.SLEEPING&&this.wakeUp(),this.torque.vadd(t,this.torque))}applyImpulse(t,e){if(e===void 0&&(e=new l),this.type!==S.DYNAMIC)return;this.sleepState===S.SLEEPING&&this.wakeUp();const s=e,i=As;i.copy(t),i.scale(this.invMass,i),this.velocity.vadd(i,this.velocity);const n=_s;s.cross(t,n),this.invInertiaWorld.vmult(n,n),this.angularVelocity.vadd(n,this.angularVelocity)}applyLocalImpulse(t,e){if(e===void 0&&(e=new l),this.type!==S.DYNAMIC)return;const s=Ts,i=Os;this.vectorToWorldFrame(t,s),this.vectorToWorldFrame(e,i),this.applyImpulse(s,i)}updateMassProperties(){const t=Ns;this.invMass=this.mass>0?1/this.mass:0;const e=this.inertia,s=this.fixedRotation;this.updateAABB(),t.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),Ot.calculateInertia(t,this.mass,e),this.invInertia.set(e.x>0&&!s?1/e.x:0,e.y>0&&!s?1/e.y:0,e.z>0&&!s?1/e.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(t,e){const s=new l;return t.vsub(this.position,s),this.angularVelocity.cross(s,e),this.velocity.vadd(e,e),e}integrate(t,e,s){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),!(this.type===S.DYNAMIC||this.type===S.KINEMATIC)||this.sleepState===S.SLEEPING)return;const i=this.velocity,n=this.angularVelocity,o=this.position,r=this.force,a=this.torque,c=this.quaternion,d=this.invMass,p=this.invInertiaWorld,h=this.linearFactor,u=d*t;i.x+=r.x*u*h.x,i.y+=r.y*u*h.y,i.z+=r.z*u*h.z;const y=p.elements,m=this.angularFactor,g=a.x*m.x,b=a.y*m.y,f=a.z*m.z;n.x+=t*(y[0]*g+y[1]*b+y[2]*f),n.y+=t*(y[3]*g+y[4]*b+y[5]*f),n.z+=t*(y[6]*g+y[7]*b+y[8]*f),o.x+=i.x*t,o.y+=i.y*t,o.z+=i.z*t,c.integrate(this.angularVelocity,t,this.angularFactor,c),e&&(s?c.normalizeFast():c.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}S.idCounter=0;S.COLLIDE_EVENT_NAME="collide";S.DYNAMIC=Qt.DYNAMIC;S.STATIC=Qt.STATIC;S.KINEMATIC=Qt.KINEMATIC;S.AWAKE=te.AWAKE;S.SLEEPY=te.SLEEPY;S.SLEEPING=te.SLEEPING;S.wakeupEvent={type:"wakeup"};S.sleepyEvent={type:"sleepy"};S.sleepEvent={type:"sleep"};const Es=new l,Is=new K,Rs=new it,Cs=new rt,Ss=new rt;new rt;const zs=new l,Ms=new l,Bs=new l,As=new l,_s=new l,Ts=new l,Os=new l,Ns=new l;class je{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(t,e,s){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(t,e){return!((t.collisionFilterGroup&e.collisionFilterMask)===0||(e.collisionFilterGroup&t.collisionFilterMask)===0||((t.type&S.STATIC)!==0||t.sleepState===S.SLEEPING)&&((e.type&S.STATIC)!==0||e.sleepState===S.SLEEPING))}intersectionTest(t,e,s,i){this.useBoundingBoxes?this.doBoundingBoxBroadphase(t,e,s,i):this.doBoundingSphereBroadphase(t,e,s,i)}doBoundingSphereBroadphase(t,e,s,i){const n=Ls;e.position.vsub(t.position,n);const o=(t.boundingRadius+e.boundingRadius)**2;n.lengthSquared()<o&&(s.push(t),i.push(e))}doBoundingBoxBroadphase(t,e,s,i){t.aabbNeedsUpdate&&t.updateAABB(),e.aabbNeedsUpdate&&e.updateAABB(),t.aabb.overlaps(e.aabb)&&(s.push(t),i.push(e))}makePairsUnique(t,e){const s=Hs,i=ks,n=js,o=t.length;for(let r=0;r!==o;r++)i[r]=t[r],n[r]=e[r];t.length=0,e.length=0;for(let r=0;r!==o;r++){const a=i[r].id,c=n[r].id,d=a<c?`${a},${c}`:`${c},${a}`;s[d]=r,s.keys.push(d)}for(let r=0;r!==s.keys.length;r++){const a=s.keys.pop(),c=s[a];t.push(i[c]),e.push(n[c]),delete s[a]}}setWorld(t){}static boundingSphereCheck(t,e){const s=new l;t.position.vsub(e.position,s);const i=t.shapes[0],n=e.shapes[0];return Math.pow(i.boundingSphereRadius+n.boundingSphereRadius,2)>s.lengthSquared()}aabbQuery(t,e,s){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const Ls=new l;new l;new K;new l;const Hs={keys:[]},ks=[],js=[];new l;new l;new l;class Fs extends je{constructor(){super()}collisionPairs(t,e,s){const i=t.bodies,n=i.length;let o,r;for(let a=0;a!==n;a++)for(let c=0;c!==a;c++)o=i[a],r=i[c],this.needBroadphaseCollision(o,r)&&this.intersectionTest(o,r,e,s)}aabbQuery(t,e,s){s===void 0&&(s=[]);for(let i=0;i<t.bodies.length;i++){const n=t.bodies[i];n.aabbNeedsUpdate&&n.updateAABB(),n.aabb.overlaps(e)&&s.push(n)}return s}}class Gt{constructor(){this.rayFromWorld=new l,this.rayToWorld=new l,this.hitNormalWorld=new l,this.hitPointWorld=new l,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(t,e,s,i,n,o,r){this.rayFromWorld.copy(t),this.rayToWorld.copy(e),this.hitNormalWorld.copy(s),this.hitPointWorld.copy(i),this.shape=n,this.body=o,this.distance=r}}let Fe,qe,Ve,Ge,Ue,De,We;const ee={CLOSEST:1,ANY:2,ALL:4};Fe=B.types.SPHERE;qe=B.types.PLANE;Ve=B.types.BOX;Ge=B.types.CYLINDER;Ue=B.types.CONVEXPOLYHEDRON;De=B.types.HEIGHTFIELD;We=B.types.TRIMESH;class X{get[Fe](){return this._intersectSphere}get[qe](){return this._intersectPlane}get[Ve](){return this._intersectBox}get[Ge](){return this._intersectConvex}get[Ue](){return this._intersectConvex}get[De](){return this._intersectHeightfield}get[We](){return this._intersectTrimesh}constructor(t,e){t===void 0&&(t=new l),e===void 0&&(e=new l),this.from=t.clone(),this.to=e.clone(),this.direction=new l,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=X.ANY,this.result=new Gt,this.hasHit=!1,this.callback=s=>{}}intersectWorld(t,e){return this.mode=e.mode||X.ANY,this.result=e.result||new Gt,this.skipBackfaces=!!e.skipBackfaces,this.collisionFilterMask=typeof e.collisionFilterMask<"u"?e.collisionFilterMask:-1,this.collisionFilterGroup=typeof e.collisionFilterGroup<"u"?e.collisionFilterGroup:-1,this.checkCollisionResponse=typeof e.checkCollisionResponse<"u"?e.checkCollisionResponse:!0,e.from&&this.from.copy(e.from),e.to&&this.to.copy(e.to),this.callback=e.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(ce),Yt.length=0,t.broadphase.aabbQuery(t,ce,Yt),this.intersectBodies(Yt),this.hasHit}intersectBody(t,e){e&&(this.result=e,this.updateDirection());const s=this.checkCollisionResponse;if(s&&!t.collisionResponse||(this.collisionFilterGroup&t.collisionFilterMask)===0||(t.collisionFilterGroup&this.collisionFilterMask)===0)return;const i=qs,n=Vs;for(let o=0,r=t.shapes.length;o<r;o++){const a=t.shapes[o];if(!(s&&!a.collisionResponse)&&(t.quaternion.mult(t.shapeOrientations[o],n),t.quaternion.vmult(t.shapeOffsets[o],i),i.vadd(t.position,i),this.intersectShape(a,n,i,t),this.result.shouldStop))break}}intersectBodies(t,e){e&&(this.result=e,this.updateDirection());for(let s=0,i=t.length;!this.result.shouldStop&&s<i;s++)this.intersectBody(t[s])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(t,e,s,i){const n=this.from;if(si(n,this.direction,s)>t.boundingSphereRadius)return;const r=this[t.type];r&&r.call(this,t,e,s,i,t)}_intersectBox(t,e,s,i,n){return this._intersectConvex(t.convexPolyhedronRepresentation,e,s,i,n)}_intersectPlane(t,e,s,i,n){const o=this.from,r=this.to,a=this.direction,c=new l(0,0,1);e.vmult(c,c);const d=new l;o.vsub(s,d);const p=d.dot(c);r.vsub(s,d);const h=d.dot(c);if(p*h>0||o.distanceTo(r)<p)return;const u=c.dot(a);if(Math.abs(u)<this.precision)return;const y=new l,m=new l,g=new l;o.vsub(s,y);const b=-c.dot(y)/u;a.scale(b,m),o.vadd(m,g),this.reportIntersection(c,g,n,i,-1)}getAABB(t){const{lowerBound:e,upperBound:s}=t,i=this.to,n=this.from;e.x=Math.min(i.x,n.x),e.y=Math.min(i.y,n.y),e.z=Math.min(i.z,n.z),s.x=Math.max(i.x,n.x),s.y=Math.max(i.y,n.y),s.z=Math.max(i.z,n.z)}_intersectHeightfield(t,e,s,i,n){t.data,t.elementSize;const o=Gs;o.from.copy(this.from),o.to.copy(this.to),G.pointToLocalFrame(s,e,o.from,o.from),G.pointToLocalFrame(s,e,o.to,o.to),o.updateDirection();const r=Us;let a,c,d,p;a=c=0,d=p=t.data.length-1;const h=new it;o.getAABB(h),t.getIndexOfPosition(h.lowerBound.x,h.lowerBound.y,r,!0),a=Math.max(a,r[0]),c=Math.max(c,r[1]),t.getIndexOfPosition(h.upperBound.x,h.upperBound.y,r,!0),d=Math.min(d,r[0]+1),p=Math.min(p,r[1]+1);for(let u=a;u<d;u++)for(let y=c;y<p;y++){if(this.result.shouldStop)return;if(t.getAabbAtIndex(u,y,h),!!h.overlapsRay(o)){if(t.getConvexTrianglePillar(u,y,!1),G.pointToWorldFrame(s,e,t.pillarOffset,Ht),this._intersectConvex(t.pillarConvex,e,Ht,i,n,he),this.result.shouldStop)return;t.getConvexTrianglePillar(u,y,!0),G.pointToWorldFrame(s,e,t.pillarOffset,Ht),this._intersectConvex(t.pillarConvex,e,Ht,i,n,he)}}}_intersectSphere(t,e,s,i,n){const o=this.from,r=this.to,a=t.radius,c=(r.x-o.x)**2+(r.y-o.y)**2+(r.z-o.z)**2,d=2*((r.x-o.x)*(o.x-s.x)+(r.y-o.y)*(o.y-s.y)+(r.z-o.z)*(o.z-s.z)),p=(o.x-s.x)**2+(o.y-s.y)**2+(o.z-s.z)**2-a**2,h=d**2-4*c*p,u=Ds,y=Ws;if(!(h<0))if(h===0)o.lerp(r,h,u),u.vsub(s,y),y.normalize(),this.reportIntersection(y,u,n,i,-1);else{const m=(-d-Math.sqrt(h))/(2*c),g=(-d+Math.sqrt(h))/(2*c);if(m>=0&&m<=1&&(o.lerp(r,m,u),u.vsub(s,y),y.normalize(),this.reportIntersection(y,u,n,i,-1)),this.result.shouldStop)return;g>=0&&g<=1&&(o.lerp(r,g,u),u.vsub(s,y),y.normalize(),this.reportIntersection(y,u,n,i,-1))}}_intersectConvex(t,e,s,i,n,o){const r=$s,a=de,c=o&&o.faceList||null,d=t.faces,p=t.vertices,h=t.faceNormals,u=this.direction,y=this.from,m=this.to,g=y.distanceTo(m),b=c?c.length:d.length,f=this.result;for(let x=0;!f.shouldStop&&x<b;x++){const P=c?c[x]:x,I=d[P],C=h[P],A=e,O=s;a.copy(p[I[0]]),A.vmult(a,a),a.vadd(O,a),a.vsub(y,a),A.vmult(C,r);const k=u.dot(r);if(Math.abs(k)<this.precision)continue;const T=r.dot(a)/k;if(!(T<0)){u.scale(T,et),et.vadd(y,et),ot.copy(p[I[0]]),A.vmult(ot,ot),O.vadd(ot,ot);for(let H=1;!f.shouldStop&&H<I.length-1;H++){lt.copy(p[I[H]]),ct.copy(p[I[H+1]]),A.vmult(lt,lt),A.vmult(ct,ct),O.vadd(lt,lt),O.vadd(ct,ct);const F=et.distanceTo(y);!(X.pointInTriangle(et,ot,lt,ct)||X.pointInTriangle(et,lt,ot,ct))||F>g||this.reportIntersection(r,et,n,i,P)}}}}_intersectTrimesh(t,e,s,i,n,o){const r=Ys,a=ti,c=ei,d=de,p=Xs,h=Ks,u=Zs,y=Qs,m=Js,g=t.indices;t.vertices;const b=this.from,f=this.to,x=this.direction;c.position.copy(s),c.quaternion.copy(e),G.vectorToLocalFrame(s,e,x,p),G.pointToLocalFrame(s,e,b,h),G.pointToLocalFrame(s,e,f,u),u.x*=t.scale.x,u.y*=t.scale.y,u.z*=t.scale.z,h.x*=t.scale.x,h.y*=t.scale.y,h.z*=t.scale.z,u.vsub(h,p),p.normalize();const P=h.distanceSquared(u);t.tree.rayQuery(this,c,a);for(let I=0,C=a.length;!this.result.shouldStop&&I!==C;I++){const A=a[I];t.getNormal(A,r),t.getVertex(g[A*3],ot),ot.vsub(h,d);const O=p.dot(r),k=r.dot(d)/O;if(k<0)continue;p.scale(k,et),et.vadd(h,et),t.getVertex(g[A*3+1],lt),t.getVertex(g[A*3+2],ct);const T=et.distanceSquared(h);!(X.pointInTriangle(et,lt,ot,ct)||X.pointInTriangle(et,ot,lt,ct))||T>P||(G.vectorToWorldFrame(e,r,m),G.pointToWorldFrame(s,e,et,y),this.reportIntersection(m,y,n,i,A))}a.length=0}reportIntersection(t,e,s,i,n){const o=this.from,r=this.to,a=o.distanceTo(e),c=this.result;if(!(this.skipBackfaces&&t.dot(this.direction)>0))switch(c.hitFaceIndex=typeof n<"u"?n:-1,this.mode){case X.ALL:this.hasHit=!0,c.set(o,r,t,e,s,i,a),c.hasHit=!0,this.callback(c);break;case X.CLOSEST:(a<c.distance||!c.hasHit)&&(this.hasHit=!0,c.hasHit=!0,c.set(o,r,t,e,s,i,a));break;case X.ANY:this.hasHit=!0,c.hasHit=!0,c.set(o,r,t,e,s,i,a),c.shouldStop=!0;break}}static pointInTriangle(t,e,s,i){i.vsub(e,xt),s.vsub(e,Mt),t.vsub(e,Xt);const n=xt.dot(xt),o=xt.dot(Mt),r=xt.dot(Xt),a=Mt.dot(Mt),c=Mt.dot(Xt);let d,p;return(d=a*r-o*c)>=0&&(p=n*c-o*r)>=0&&d+p<n*a-o*o}}X.CLOSEST=ee.CLOSEST;X.ANY=ee.ANY;X.ALL=ee.ALL;const ce=new it,Yt=[],Mt=new l,Xt=new l,qs=new l,Vs=new K,et=new l,ot=new l,lt=new l,ct=new l;new l;new Gt;const he={faceList:[0]},Ht=new l,Gs=new X,Us=[],Ds=new l,Ws=new l,$s=new l;new l;new l;const de=new l,Ys=new l,Xs=new l,Ks=new l,Zs=new l,Js=new l,Qs=new l;new it;const ti=[],ei=new G,xt=new l,kt=new l;function si(w,t,e){e.vsub(w,xt);const s=xt.dot(t);return t.scale(s,kt),kt.vadd(w,kt),e.distanceTo(kt)}class St extends je{static checkBounds(t,e,s){let i,n;s===0?(i=t.position.x,n=e.position.x):s===1?(i=t.position.y,n=e.position.y):s===2&&(i=t.position.z,n=e.position.z);const o=t.boundingRadius,r=e.boundingRadius,a=i+o;return n-r<a}static insertionSortX(t){for(let e=1,s=t.length;e<s;e++){const i=t[e];let n;for(n=e-1;n>=0&&!(t[n].aabb.lowerBound.x<=i.aabb.lowerBound.x);n--)t[n+1]=t[n];t[n+1]=i}return t}static insertionSortY(t){for(let e=1,s=t.length;e<s;e++){const i=t[e];let n;for(n=e-1;n>=0&&!(t[n].aabb.lowerBound.y<=i.aabb.lowerBound.y);n--)t[n+1]=t[n];t[n+1]=i}return t}static insertionSortZ(t){for(let e=1,s=t.length;e<s;e++){const i=t[e];let n;for(n=e-1;n>=0&&!(t[n].aabb.lowerBound.z<=i.aabb.lowerBound.z);n--)t[n+1]=t[n];t[n+1]=i}return t}constructor(t){super(),this.axisList=[],this.world=null,this.axisIndex=0;const e=this.axisList;this._addBodyHandler=s=>{e.push(s.body)},this._removeBodyHandler=s=>{const i=e.indexOf(s.body);i!==-1&&e.splice(i,1)},t&&this.setWorld(t)}setWorld(t){this.axisList.length=0;for(let e=0;e<t.bodies.length;e++)this.axisList.push(t.bodies[e]);t.removeEventListener("addBody",this._addBodyHandler),t.removeEventListener("removeBody",this._removeBodyHandler),t.addEventListener("addBody",this._addBodyHandler),t.addEventListener("removeBody",this._removeBodyHandler),this.world=t,this.dirty=!0}collisionPairs(t,e,s){const i=this.axisList,n=i.length,o=this.axisIndex;let r,a;for(this.dirty&&(this.sortList(),this.dirty=!1),r=0;r!==n;r++){const c=i[r];for(a=r+1;a<n;a++){const d=i[a];if(this.needBroadphaseCollision(c,d)){if(!St.checkBounds(c,d,o))break;this.intersectionTest(c,d,e,s)}}}}sortList(){const t=this.axisList,e=this.axisIndex,s=t.length;for(let i=0;i!==s;i++){const n=t[i];n.aabbNeedsUpdate&&n.updateAABB()}e===0?St.insertionSortX(t):e===1?St.insertionSortY(t):e===2&&St.insertionSortZ(t)}autoDetectAxis(){let t=0,e=0,s=0,i=0,n=0,o=0;const r=this.axisList,a=r.length,c=1/a;for(let u=0;u!==a;u++){const y=r[u],m=y.position.x;t+=m,e+=m*m;const g=y.position.y;s+=g,i+=g*g;const b=y.position.z;n+=b,o+=b*b}const d=e-t*t*c,p=i-s*s*c,h=o-n*n*c;d>p?d>h?this.axisIndex=0:this.axisIndex=2:p>h?this.axisIndex=1:this.axisIndex=2}aabbQuery(t,e,s){s===void 0&&(s=[]),this.dirty&&(this.sortList(),this.dirty=!1);const i=this.axisIndex;let n="x";i===1&&(n="y"),i===2&&(n="z");const o=this.axisList;e.lowerBound[n],e.upperBound[n];for(let r=0;r<o.length;r++){const a=o[r];a.aabbNeedsUpdate&&a.updateAABB(),a.aabb.overlaps(e)&&s.push(a)}return s}}class ii{static defaults(t,e){t===void 0&&(t={});for(let s in e)s in t||(t[s]=e[s]);return t}}class pe{constructor(){this.spatial=new l,this.rotational=new l}multiplyElement(t){return t.spatial.dot(this.spatial)+t.rotational.dot(this.rotational)}multiplyVectors(t,e){return t.dot(this.spatial)+e.dot(this.rotational)}}class Nt{constructor(t,e,s,i){s===void 0&&(s=-1e6),i===void 0&&(i=1e6),this.id=Nt.idCounter++,this.minForce=s,this.maxForce=i,this.bi=t,this.bj=e,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new pe,this.jacobianElementB=new pe,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(t,e,s){const i=e,n=t,o=s;this.a=4/(o*(1+4*i)),this.b=4*i/(1+4*i),this.eps=4/(o*o*n*(1+4*i))}computeB(t,e,s){const i=this.computeGW(),n=this.computeGq(),o=this.computeGiMf();return-n*t-i*e-o*s}computeGq(){const t=this.jacobianElementA,e=this.jacobianElementB,s=this.bi,i=this.bj,n=s.position,o=i.position;return t.spatial.dot(n)+e.spatial.dot(o)}computeGW(){const t=this.jacobianElementA,e=this.jacobianElementB,s=this.bi,i=this.bj,n=s.velocity,o=i.velocity,r=s.angularVelocity,a=i.angularVelocity;return t.multiplyVectors(n,r)+e.multiplyVectors(o,a)}computeGWlambda(){const t=this.jacobianElementA,e=this.jacobianElementB,s=this.bi,i=this.bj,n=s.vlambda,o=i.vlambda,r=s.wlambda,a=i.wlambda;return t.multiplyVectors(n,r)+e.multiplyVectors(o,a)}computeGiMf(){const t=this.jacobianElementA,e=this.jacobianElementB,s=this.bi,i=this.bj,n=s.force,o=s.torque,r=i.force,a=i.torque,c=s.invMassSolve,d=i.invMassSolve;return n.scale(c,ue),r.scale(d,ye),s.invInertiaWorldSolve.vmult(o,fe),i.invInertiaWorldSolve.vmult(a,me),t.multiplyVectors(ue,fe)+e.multiplyVectors(ye,me)}computeGiMGt(){const t=this.jacobianElementA,e=this.jacobianElementB,s=this.bi,i=this.bj,n=s.invMassSolve,o=i.invMassSolve,r=s.invInertiaWorldSolve,a=i.invInertiaWorldSolve;let c=n+o;return r.vmult(t.rotational,jt),c+=jt.dot(t.rotational),a.vmult(e.rotational,jt),c+=jt.dot(e.rotational),c}addToWlambda(t){const e=this.jacobianElementA,s=this.jacobianElementB,i=this.bi,n=this.bj,o=ni;i.vlambda.addScaledVector(i.invMassSolve*t,e.spatial,i.vlambda),n.vlambda.addScaledVector(n.invMassSolve*t,s.spatial,n.vlambda),i.invInertiaWorldSolve.vmult(e.rotational,o),i.wlambda.addScaledVector(t,o,i.wlambda),n.invInertiaWorldSolve.vmult(s.rotational,o),n.wlambda.addScaledVector(t,o,n.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}Nt.idCounter=0;const ue=new l,ye=new l,fe=new l,me=new l,jt=new l,ni=new l;class oi extends Nt{constructor(t,e,s){s===void 0&&(s=1e6),super(t,e,0,s),this.restitution=0,this.ri=new l,this.rj=new l,this.ni=new l}computeB(t){const e=this.a,s=this.b,i=this.bi,n=this.bj,o=this.ri,r=this.rj,a=ri,c=ai,d=i.velocity,p=i.angularVelocity;i.force,i.torque;const h=n.velocity,u=n.angularVelocity;n.force,n.torque;const y=li,m=this.jacobianElementA,g=this.jacobianElementB,b=this.ni;o.cross(b,a),r.cross(b,c),b.negate(m.spatial),a.negate(m.rotational),g.spatial.copy(b),g.rotational.copy(c),y.copy(n.position),y.vadd(r,y),y.vsub(i.position,y),y.vsub(o,y);const f=b.dot(y),x=this.restitution+1,P=x*h.dot(b)-x*d.dot(b)+u.dot(c)-p.dot(a),I=this.computeGiMf();return-f*e-P*s-t*I}getImpactVelocityAlongNormal(){const t=ci,e=hi,s=di,i=pi,n=ui;return this.bi.position.vadd(this.ri,s),this.bj.position.vadd(this.rj,i),this.bi.getVelocityAtWorldPoint(s,t),this.bj.getVelocityAtWorldPoint(i,e),t.vsub(e,n),this.ni.dot(n)}}const ri=new l,ai=new l,li=new l,ci=new l,hi=new l,di=new l,pi=new l,ui=new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;class ge extends Nt{constructor(t,e,s){super(t,e,-s,s),this.ri=new l,this.rj=new l,this.t=new l}computeB(t){this.a;const e=this.b;this.bi,this.bj;const s=this.ri,i=this.rj,n=yi,o=fi,r=this.t;s.cross(r,n),i.cross(r,o);const a=this.jacobianElementA,c=this.jacobianElementB;r.negate(a.spatial),n.negate(a.rotational),c.spatial.copy(r),c.rotational.copy(o);const d=this.computeGW(),p=this.computeGiMf();return-d*e-t*p}}const yi=new l,fi=new l;class Pt{constructor(t,e,s){s=ii.defaults(s,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=Pt.idCounter++,this.materials=[t,e],this.friction=s.friction,this.restitution=s.restitution,this.contactEquationStiffness=s.contactEquationStiffness,this.contactEquationRelaxation=s.contactEquationRelaxation,this.frictionEquationStiffness=s.frictionEquationStiffness,this.frictionEquationRelaxation=s.frictionEquationRelaxation}}Pt.idCounter=0;class Et{constructor(t){t===void 0&&(t={});let e="";typeof t=="string"&&(e=t,t={}),this.name=e,this.id=Et.idCounter++,this.friction=typeof t.friction<"u"?t.friction:-1,this.restitution=typeof t.restitution<"u"?t.restitution:-1}}Et.idCounter=0;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new X;new l;new l;new l;new l(1,0,0),new l(0,1,0),new l(0,0,1);new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;class mi extends B{constructor(t){if(super({type:B.types.SPHERE}),this.radius=t!==void 0?t:1,this.radius<0)throw new Error("The sphere radius cannot be negative.");this.updateBoundingSphereRadius()}calculateLocalInertia(t,e){e===void 0&&(e=new l);const s=2*t*this.radius*this.radius/5;return e.x=s,e.y=s,e.z=s,e}volume(){return 4*Math.PI*Math.pow(this.radius,3)/3}updateBoundingSphereRadius(){this.boundingSphereRadius=this.radius}calculateWorldAABB(t,e,s,i){const n=this.radius,o=["x","y","z"];for(let r=0;r<o.length;r++){const a=o[r];s[a]=t[a]-n,i[a]=t[a]+n}}}new l;new l;new l;new l;new l;new l;new l;new l;new l;class gi extends B{constructor(){super({type:B.types.PLANE}),this.worldNormal=new l,this.worldNormalNeedsUpdate=!0,this.boundingSphereRadius=Number.MAX_VALUE}computeWorldNormal(t){const e=this.worldNormal;e.set(0,0,1),t.vmult(e,e),this.worldNormalNeedsUpdate=!1}calculateLocalInertia(t,e){return e===void 0&&(e=new l),e}volume(){return Number.MAX_VALUE}calculateWorldAABB(t,e,s,i){ht.set(0,0,1),e.vmult(ht,ht);const n=Number.MAX_VALUE;s.set(-n,-n,-n),i.set(n,n,n),ht.x===1?i.x=t.x:ht.x===-1&&(s.x=t.x),ht.y===1?i.y=t.y:ht.y===-1&&(s.y=t.y),ht.z===1?i.z=t.z:ht.z===-1&&(s.z=t.z)}updateBoundingSphereRadius(){this.boundingSphereRadius=Number.MAX_VALUE}}const ht=new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new it;new l;new it;new l;new l;new l;new l;new l;new l;new l;new it;new l;new G;new it;class bi{constructor(){this.equations=[]}solve(t,e){return 0}addEquation(t){t.enabled&&!t.bi.isTrigger&&!t.bj.isTrigger&&this.equations.push(t)}removeEquation(t){const e=this.equations,s=e.indexOf(t);s!==-1&&e.splice(s,1)}removeAllEquations(){this.equations.length=0}}class vi extends bi{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(t,e){let s=0;const i=this.iterations,n=this.tolerance*this.tolerance,o=this.equations,r=o.length,a=e.bodies,c=a.length,d=t;let p,h,u,y,m,g;if(r!==0)for(let P=0;P!==c;P++)a[P].updateSolveMassProperties();const b=xi,f=Pi,x=wi;b.length=r,f.length=r,x.length=r;for(let P=0;P!==r;P++){const I=o[P];x[P]=0,f[P]=I.computeB(d),b[P]=1/I.computeC()}if(r!==0){for(let C=0;C!==c;C++){const A=a[C],O=A.vlambda,k=A.wlambda;O.set(0,0,0),k.set(0,0,0)}for(s=0;s!==i;s++){y=0;for(let C=0;C!==r;C++){const A=o[C];p=f[C],h=b[C],g=x[C],m=A.computeGWlambda(),u=h*(p-m-A.eps*g),g+u<A.minForce?u=A.minForce-g:g+u>A.maxForce&&(u=A.maxForce-g),x[C]+=u,y+=u>0?u:-u,A.addToWlambda(u)}if(y*y<n)break}for(let C=0;C!==c;C++){const A=a[C],O=A.velocity,k=A.angularVelocity;A.vlambda.vmul(A.linearFactor,A.vlambda),O.vadd(A.vlambda,O),A.wlambda.vmul(A.angularFactor,A.wlambda),k.vadd(A.wlambda,k)}let P=o.length;const I=1/d;for(;P--;)o[P].multiplier=x[P]*I}return s}}const wi=[],xi=[],Pi=[];class Ei{constructor(){this.objects=[],this.type=Object}release(){const t=arguments.length;for(let e=0;e!==t;e++)this.objects.push(e<0||arguments.length<=e?void 0:arguments[e]);return this}get(){return this.objects.length===0?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(t){const e=this.objects;for(;e.length>t;)e.pop();for(;e.length<t;)e.push(this.constructObject());return this}}class Ii extends Ei{constructor(){super(...arguments),this.type=l}constructObject(){return new l}}const D={sphereSphere:B.types.SPHERE,spherePlane:B.types.SPHERE|B.types.PLANE,boxBox:B.types.BOX|B.types.BOX,sphereBox:B.types.SPHERE|B.types.BOX,planeBox:B.types.PLANE|B.types.BOX,convexConvex:B.types.CONVEXPOLYHEDRON,sphereConvex:B.types.SPHERE|B.types.CONVEXPOLYHEDRON,planeConvex:B.types.PLANE|B.types.CONVEXPOLYHEDRON,boxConvex:B.types.BOX|B.types.CONVEXPOLYHEDRON,sphereHeightfield:B.types.SPHERE|B.types.HEIGHTFIELD,boxHeightfield:B.types.BOX|B.types.HEIGHTFIELD,convexHeightfield:B.types.CONVEXPOLYHEDRON|B.types.HEIGHTFIELD,sphereParticle:B.types.PARTICLE|B.types.SPHERE,planeParticle:B.types.PLANE|B.types.PARTICLE,boxParticle:B.types.BOX|B.types.PARTICLE,convexParticle:B.types.PARTICLE|B.types.CONVEXPOLYHEDRON,cylinderCylinder:B.types.CYLINDER,sphereCylinder:B.types.SPHERE|B.types.CYLINDER,planeCylinder:B.types.PLANE|B.types.CYLINDER,boxCylinder:B.types.BOX|B.types.CYLINDER,convexCylinder:B.types.CONVEXPOLYHEDRON|B.types.CYLINDER,heightfieldCylinder:B.types.HEIGHTFIELD|B.types.CYLINDER,particleCylinder:B.types.PARTICLE|B.types.CYLINDER,sphereTrimesh:B.types.SPHERE|B.types.TRIMESH,planeTrimesh:B.types.PLANE|B.types.TRIMESH};class Ri{get[D.sphereSphere](){return this.sphereSphere}get[D.spherePlane](){return this.spherePlane}get[D.boxBox](){return this.boxBox}get[D.sphereBox](){return this.sphereBox}get[D.planeBox](){return this.planeBox}get[D.convexConvex](){return this.convexConvex}get[D.sphereConvex](){return this.sphereConvex}get[D.planeConvex](){return this.planeConvex}get[D.boxConvex](){return this.boxConvex}get[D.sphereHeightfield](){return this.sphereHeightfield}get[D.boxHeightfield](){return this.boxHeightfield}get[D.convexHeightfield](){return this.convexHeightfield}get[D.sphereParticle](){return this.sphereParticle}get[D.planeParticle](){return this.planeParticle}get[D.boxParticle](){return this.boxParticle}get[D.convexParticle](){return this.convexParticle}get[D.cylinderCylinder](){return this.convexConvex}get[D.sphereCylinder](){return this.sphereConvex}get[D.planeCylinder](){return this.planeConvex}get[D.boxCylinder](){return this.boxConvex}get[D.convexCylinder](){return this.convexConvex}get[D.heightfieldCylinder](){return this.heightfieldCylinder}get[D.particleCylinder](){return this.particleCylinder}get[D.sphereTrimesh](){return this.sphereTrimesh}get[D.planeTrimesh](){return this.planeTrimesh}constructor(t){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new Ii,this.world=t,this.currentContactMaterial=t.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(t,e,s,i,n,o){let r;this.contactPointPool.length?(r=this.contactPointPool.pop(),r.bi=t,r.bj=e):r=new oi(t,e),r.enabled=t.collisionResponse&&e.collisionResponse&&s.collisionResponse&&i.collisionResponse;const a=this.currentContactMaterial;r.restitution=a.restitution,r.setSpookParams(a.contactEquationStiffness,a.contactEquationRelaxation,this.world.dt);const c=s.material||t.material,d=i.material||e.material;return c&&d&&c.restitution>=0&&d.restitution>=0&&(r.restitution=c.restitution*d.restitution),r.si=n||s,r.sj=o||i,r}createFrictionEquationsFromContact(t,e){const s=t.bi,i=t.bj,n=t.si,o=t.sj,r=this.world,a=this.currentContactMaterial;let c=a.friction;const d=n.material||s.material,p=o.material||i.material;if(d&&p&&d.friction>=0&&p.friction>=0&&(c=d.friction*p.friction),c>0){const h=c*(r.frictionGravity||r.gravity).length();let u=s.invMass+i.invMass;u>0&&(u=1/u);const y=this.frictionEquationPool,m=y.length?y.pop():new ge(s,i,h*u),g=y.length?y.pop():new ge(s,i,h*u);return m.bi=g.bi=s,m.bj=g.bj=i,m.minForce=g.minForce=-h*u,m.maxForce=g.maxForce=h*u,m.ri.copy(t.ri),m.rj.copy(t.rj),g.ri.copy(t.ri),g.rj.copy(t.rj),t.ni.tangents(m.t,g.t),m.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,r.dt),g.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,r.dt),m.enabled=g.enabled=t.enabled,e.push(m,g),!0}return!1}createFrictionFromAverage(t){let e=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(e,this.frictionResult)||t===1)return;const s=this.frictionResult[this.frictionResult.length-2],i=this.frictionResult[this.frictionResult.length-1];wt.setZero(),Rt.setZero(),Ct.setZero();const n=e.bi;e.bj;for(let r=0;r!==t;r++)e=this.result[this.result.length-1-r],e.bi!==n?(wt.vadd(e.ni,wt),Rt.vadd(e.ri,Rt),Ct.vadd(e.rj,Ct)):(wt.vsub(e.ni,wt),Rt.vadd(e.rj,Rt),Ct.vadd(e.ri,Ct));const o=1/t;Rt.scale(o,s.ri),Ct.scale(o,s.rj),i.ri.copy(s.ri),i.rj.copy(s.rj),wt.normalize(),wt.tangents(s.t,i.t)}getContacts(t,e,s,i,n,o,r){this.contactPointPool=n,this.frictionEquationPool=r,this.result=i,this.frictionResult=o;const a=zi,c=Mi,d=Ci,p=Si;for(let h=0,u=t.length;h!==u;h++){const y=t[h],m=e[h];let g=null;y.material&&m.material&&(g=s.getContactMaterial(y.material,m.material)||null);const b=y.type&S.KINEMATIC&&m.type&S.STATIC||y.type&S.STATIC&&m.type&S.KINEMATIC||y.type&S.KINEMATIC&&m.type&S.KINEMATIC;for(let f=0;f<y.shapes.length;f++){y.quaternion.mult(y.shapeOrientations[f],a),y.quaternion.vmult(y.shapeOffsets[f],d),d.vadd(y.position,d);const x=y.shapes[f];for(let P=0;P<m.shapes.length;P++){m.quaternion.mult(m.shapeOrientations[P],c),m.quaternion.vmult(m.shapeOffsets[P],p),p.vadd(m.position,p);const I=m.shapes[P];if(!(x.collisionFilterMask&I.collisionFilterGroup&&I.collisionFilterMask&x.collisionFilterGroup)||d.distanceTo(p)>x.boundingSphereRadius+I.boundingSphereRadius)continue;let C=null;x.material&&I.material&&(C=s.getContactMaterial(x.material,I.material)||null),this.currentContactMaterial=C||g||s.defaultContactMaterial;const A=x.type|I.type,O=this[A];if(O){let k=!1;x.type<I.type?k=O.call(this,x,I,d,p,a,c,y,m,x,I,b):k=O.call(this,I,x,p,d,c,a,m,y,x,I,b),k&&b&&(s.shapeOverlapKeeper.set(x.id,I.id),s.bodyOverlapKeeper.set(y.id,m.id))}}}}}sphereSphere(t,e,s,i,n,o,r,a,c,d,p){if(p)return s.distanceSquared(i)<(t.radius+e.radius)**2;const h=this.createContactEquation(r,a,t,e,c,d);i.vsub(s,h.ni),h.ni.normalize(),h.ri.copy(h.ni),h.rj.copy(h.ni),h.ri.scale(t.radius,h.ri),h.rj.scale(-e.radius,h.rj),h.ri.vadd(s,h.ri),h.ri.vsub(r.position,h.ri),h.rj.vadd(i,h.rj),h.rj.vsub(a.position,h.rj),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}spherePlane(t,e,s,i,n,o,r,a,c,d,p){const h=this.createContactEquation(r,a,t,e,c,d);if(h.ni.set(0,0,1),o.vmult(h.ni,h.ni),h.ni.negate(h.ni),h.ni.normalize(),h.ni.scale(t.radius,h.ri),s.vsub(i,Ft),h.ni.scale(h.ni.dot(Ft),be),Ft.vsub(be,h.rj),-Ft.dot(h.ni)<=t.radius){if(p)return!0;const u=h.ri,y=h.rj;u.vadd(s,u),u.vsub(r.position,u),y.vadd(i,y),y.vsub(a.position,y),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}}boxBox(t,e,s,i,n,o,r,a,c,d,p){return t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e.convexPolyhedronRepresentation,s,i,n,o,r,a,t,e,p)}sphereBox(t,e,s,i,n,o,r,a,c,d,p){const h=this.v3pool,u=en;s.vsub(i,qt),e.getSideNormals(u,o);const y=t.radius;let m=!1;const g=nn,b=on,f=rn;let x=null,P=0,I=0,C=0,A=null;for(let R=0,$=u.length;R!==$&&m===!1;R++){const j=Ji;j.copy(u[R]);const q=j.length();j.normalize();const tt=qt.dot(j);if(tt<q+y&&tt>0){const Q=Qi,N=tn;Q.copy(u[(R+1)%3]),N.copy(u[(R+2)%3]);const It=Q.length(),Lt=N.length();Q.normalize(),N.normalize();const Ut=qt.dot(Q),Dt=qt.dot(N);if(Ut<It&&Ut>-It&&Dt<Lt&&Dt>-Lt){const se=Math.abs(tt-q-y);if((A===null||se<A)&&(A=se,I=Ut,C=Dt,x=q,g.copy(j),b.copy(Q),f.copy(N),P++,p))return!0}}}if(P){m=!0;const R=this.createContactEquation(r,a,t,e,c,d);g.scale(-y,R.ri),R.ni.copy(g),R.ni.negate(R.ni),g.scale(x,g),b.scale(I,b),g.vadd(b,g),f.scale(C,f),g.vadd(f,R.rj),R.ri.vadd(s,R.ri),R.ri.vsub(r.position,R.ri),R.rj.vadd(i,R.rj),R.rj.vsub(a.position,R.rj),this.result.push(R),this.createFrictionEquationsFromContact(R,this.frictionResult)}let O=h.get();const k=sn;for(let R=0;R!==2&&!m;R++)for(let $=0;$!==2&&!m;$++)for(let j=0;j!==2&&!m;j++)if(O.set(0,0,0),R?O.vadd(u[0],O):O.vsub(u[0],O),$?O.vadd(u[1],O):O.vsub(u[1],O),j?O.vadd(u[2],O):O.vsub(u[2],O),i.vadd(O,k),k.vsub(s,k),k.lengthSquared()<y*y){if(p)return!0;m=!0;const q=this.createContactEquation(r,a,t,e,c,d);q.ri.copy(k),q.ri.normalize(),q.ni.copy(q.ri),q.ri.scale(y,q.ri),q.rj.copy(O),q.ri.vadd(s,q.ri),q.ri.vsub(r.position,q.ri),q.rj.vadd(i,q.rj),q.rj.vsub(a.position,q.rj),this.result.push(q),this.createFrictionEquationsFromContact(q,this.frictionResult)}h.release(O),O=null;const T=h.get(),H=h.get(),F=h.get(),E=h.get(),M=h.get(),z=u.length;for(let R=0;R!==z&&!m;R++)for(let $=0;$!==z&&!m;$++)if(R%3!==$%3){u[$].cross(u[R],T),T.normalize(),u[R].vadd(u[$],H),F.copy(s),F.vsub(H,F),F.vsub(i,F);const j=F.dot(T);T.scale(j,E);let q=0;for(;q===R%3||q===$%3;)q++;M.copy(s),M.vsub(E,M),M.vsub(H,M),M.vsub(i,M);const tt=Math.abs(j),Q=M.length();if(tt<u[q].length()&&Q<y){if(p)return!0;m=!0;const N=this.createContactEquation(r,a,t,e,c,d);H.vadd(E,N.rj),N.rj.copy(N.rj),M.negate(N.ni),N.ni.normalize(),N.ri.copy(N.rj),N.ri.vadd(i,N.ri),N.ri.vsub(s,N.ri),N.ri.normalize(),N.ri.scale(y,N.ri),N.ri.vadd(s,N.ri),N.ri.vsub(r.position,N.ri),N.rj.vadd(i,N.rj),N.rj.vsub(a.position,N.rj),this.result.push(N),this.createFrictionEquationsFromContact(N,this.frictionResult)}}h.release(T,H,F,E,M)}planeBox(t,e,s,i,n,o,r,a,c,d,p){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,e.convexPolyhedronRepresentation.id=e.id,this.planeConvex(t,e.convexPolyhedronRepresentation,s,i,n,o,r,a,t,e,p)}convexConvex(t,e,s,i,n,o,r,a,c,d,p,h,u){const y=xn;if(!(s.distanceTo(i)>t.boundingSphereRadius+e.boundingSphereRadius)&&t.findSeparatingAxis(e,s,n,i,o,y,h,u)){const m=[],g=Pn;t.clipAgainstHull(s,n,e,i,o,y,-100,100,m);let b=0;for(let f=0;f!==m.length;f++){if(p)return!0;const x=this.createContactEquation(r,a,t,e,c,d),P=x.ri,I=x.rj;y.negate(x.ni),m[f].normal.negate(g),g.scale(m[f].depth,g),m[f].point.vadd(g,P),I.copy(m[f].point),P.vsub(s,P),I.vsub(i,I),P.vadd(s,P),P.vsub(r.position,P),I.vadd(i,I),I.vsub(a.position,I),this.result.push(x),b++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(x,this.frictionResult)}this.enableFrictionReduction&&b&&this.createFrictionFromAverage(b)}}sphereConvex(t,e,s,i,n,o,r,a,c,d,p){const h=this.v3pool;s.vsub(i,an);const u=e.faceNormals,y=e.faces,m=e.vertices,g=t.radius;let b=!1;for(let f=0;f!==m.length;f++){const x=m[f],P=dn;o.vmult(x,P),i.vadd(P,P);const I=hn;if(P.vsub(s,I),I.lengthSquared()<g*g){if(p)return!0;b=!0;const C=this.createContactEquation(r,a,t,e,c,d);C.ri.copy(I),C.ri.normalize(),C.ni.copy(C.ri),C.ri.scale(g,C.ri),P.vsub(i,C.rj),C.ri.vadd(s,C.ri),C.ri.vsub(r.position,C.ri),C.rj.vadd(i,C.rj),C.rj.vsub(a.position,C.rj),this.result.push(C),this.createFrictionEquationsFromContact(C,this.frictionResult);return}}for(let f=0,x=y.length;f!==x&&b===!1;f++){const P=u[f],I=y[f],C=pn;o.vmult(P,C);const A=un;o.vmult(m[I[0]],A),A.vadd(i,A);const O=yn;C.scale(-g,O),s.vadd(O,O);const k=fn;O.vsub(A,k);const T=k.dot(C),H=mn;if(s.vsub(A,H),T<0&&H.dot(C)>0){const F=[];for(let E=0,M=I.length;E!==M;E++){const z=h.get();o.vmult(m[I[E]],z),i.vadd(z,z),F.push(z)}if(Zi(F,C,s)){if(p)return!0;b=!0;const E=this.createContactEquation(r,a,t,e,c,d);C.scale(-g,E.ri),C.negate(E.ni);const M=h.get();C.scale(-T,M);const z=h.get();C.scale(-g,z),s.vsub(i,E.rj),E.rj.vadd(z,E.rj),E.rj.vadd(M,E.rj),E.rj.vadd(i,E.rj),E.rj.vsub(a.position,E.rj),E.ri.vadd(s,E.ri),E.ri.vsub(r.position,E.ri),h.release(M),h.release(z),this.result.push(E),this.createFrictionEquationsFromContact(E,this.frictionResult);for(let R=0,$=F.length;R!==$;R++)h.release(F[R]);return}else for(let E=0;E!==I.length;E++){const M=h.get(),z=h.get();o.vmult(m[I[(E+1)%I.length]],M),o.vmult(m[I[(E+2)%I.length]],z),i.vadd(M,M),i.vadd(z,z);const R=ln;z.vsub(M,R);const $=cn;R.unit($);const j=h.get(),q=h.get();s.vsub(M,q);const tt=q.dot($);$.scale(tt,j),j.vadd(M,j);const Q=h.get();if(j.vsub(s,Q),tt>0&&tt*tt<R.lengthSquared()&&Q.lengthSquared()<g*g){if(p)return!0;const N=this.createContactEquation(r,a,t,e,c,d);j.vsub(i,N.rj),j.vsub(s,N.ni),N.ni.normalize(),N.ni.scale(g,N.ri),N.rj.vadd(i,N.rj),N.rj.vsub(a.position,N.rj),N.ri.vadd(s,N.ri),N.ri.vsub(r.position,N.ri),this.result.push(N),this.createFrictionEquationsFromContact(N,this.frictionResult);for(let It=0,Lt=F.length;It!==Lt;It++)h.release(F[It]);h.release(M),h.release(z),h.release(j),h.release(Q),h.release(q);return}h.release(M),h.release(z),h.release(j),h.release(Q),h.release(q)}for(let E=0,M=F.length;E!==M;E++)h.release(F[E])}}}planeConvex(t,e,s,i,n,o,r,a,c,d,p){const h=gn,u=bn;u.set(0,0,1),n.vmult(u,u);let y=0;const m=vn;for(let g=0;g!==e.vertices.length;g++)if(h.copy(e.vertices[g]),o.vmult(h,h),i.vadd(h,h),h.vsub(s,m),u.dot(m)<=0){if(p)return!0;const f=this.createContactEquation(r,a,t,e,c,d),x=wn;u.scale(u.dot(m),x),h.vsub(x,x),x.vsub(s,f.ri),f.ni.copy(u),h.vsub(i,f.rj),f.ri.vadd(s,f.ri),f.ri.vsub(r.position,f.ri),f.rj.vadd(i,f.rj),f.rj.vsub(a.position,f.rj),this.result.push(f),y++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(f,this.frictionResult)}this.enableFrictionReduction&&y&&this.createFrictionFromAverage(y)}boxConvex(t,e,s,i,n,o,r,a,c,d,p){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e,s,i,n,o,r,a,t,e,p)}sphereHeightfield(t,e,s,i,n,o,r,a,c,d,p){const h=e.data,u=t.radius,y=e.elementSize,m=On,g=Tn;G.pointToLocalFrame(i,o,s,g);let b=Math.floor((g.x-u)/y)-1,f=Math.ceil((g.x+u)/y)+1,x=Math.floor((g.y-u)/y)-1,P=Math.ceil((g.y+u)/y)+1;if(f<0||P<0||b>h.length||x>h[0].length)return;b<0&&(b=0),f<0&&(f=0),x<0&&(x=0),P<0&&(P=0),b>=h.length&&(b=h.length-1),f>=h.length&&(f=h.length-1),P>=h[0].length&&(P=h[0].length-1),x>=h[0].length&&(x=h[0].length-1);const I=[];e.getRectMinMax(b,x,f,P,I);const C=I[0],A=I[1];if(g.z-u>A||g.z+u<C)return;const O=this.result;for(let k=b;k<f;k++)for(let T=x;T<P;T++){const H=O.length;let F=!1;if(e.getConvexTrianglePillar(k,T,!1),G.pointToWorldFrame(i,o,e.pillarOffset,m),s.distanceTo(m)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(F=this.sphereConvex(t,e.pillarConvex,s,m,n,o,r,a,t,e,p)),p&&F||(e.getConvexTrianglePillar(k,T,!0),G.pointToWorldFrame(i,o,e.pillarOffset,m),s.distanceTo(m)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(F=this.sphereConvex(t,e.pillarConvex,s,m,n,o,r,a,t,e,p)),p&&F))return!0;if(O.length-H>2)return}}boxHeightfield(t,e,s,i,n,o,r,a,c,d,p){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexHeightfield(t.convexPolyhedronRepresentation,e,s,i,n,o,r,a,t,e,p)}convexHeightfield(t,e,s,i,n,o,r,a,c,d,p){const h=e.data,u=e.elementSize,y=t.boundingSphereRadius,m=An,g=_n,b=Bn;G.pointToLocalFrame(i,o,s,b);let f=Math.floor((b.x-y)/u)-1,x=Math.ceil((b.x+y)/u)+1,P=Math.floor((b.y-y)/u)-1,I=Math.ceil((b.y+y)/u)+1;if(x<0||I<0||f>h.length||P>h[0].length)return;f<0&&(f=0),x<0&&(x=0),P<0&&(P=0),I<0&&(I=0),f>=h.length&&(f=h.length-1),x>=h.length&&(x=h.length-1),I>=h[0].length&&(I=h[0].length-1),P>=h[0].length&&(P=h[0].length-1);const C=[];e.getRectMinMax(f,P,x,I,C);const A=C[0],O=C[1];if(!(b.z-y>O||b.z+y<A))for(let k=f;k<x;k++)for(let T=P;T<I;T++){let H=!1;if(e.getConvexTrianglePillar(k,T,!1),G.pointToWorldFrame(i,o,e.pillarOffset,m),s.distanceTo(m)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(H=this.convexConvex(t,e.pillarConvex,s,m,n,o,r,a,null,null,p,g,null)),p&&H||(e.getConvexTrianglePillar(k,T,!0),G.pointToWorldFrame(i,o,e.pillarOffset,m),s.distanceTo(m)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(H=this.convexConvex(t,e.pillarConvex,s,m,n,o,r,a,null,null,p,g,null)),p&&H))return!0}}sphereParticle(t,e,s,i,n,o,r,a,c,d,p){const h=Cn;if(h.set(0,0,1),i.vsub(s,h),h.lengthSquared()<=t.radius*t.radius){if(p)return!0;const y=this.createContactEquation(a,r,e,t,c,d);h.normalize(),y.rj.copy(h),y.rj.scale(t.radius,y.rj),y.ni.copy(h),y.ni.negate(y.ni),y.ri.set(0,0,0),this.result.push(y),this.createFrictionEquationsFromContact(y,this.frictionResult)}}planeParticle(t,e,s,i,n,o,r,a,c,d,p){const h=En;h.set(0,0,1),r.quaternion.vmult(h,h);const u=In;if(i.vsub(r.position,u),h.dot(u)<=0){if(p)return!0;const m=this.createContactEquation(a,r,e,t,c,d);m.ni.copy(h),m.ni.negate(m.ni),m.ri.set(0,0,0);const g=Rn;h.scale(h.dot(i),g),i.vsub(g,g),m.rj.copy(g),this.result.push(m),this.createFrictionEquationsFromContact(m,this.frictionResult)}}boxParticle(t,e,s,i,n,o,r,a,c,d,p){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexParticle(t.convexPolyhedronRepresentation,e,s,i,n,o,r,a,t,e,p)}convexParticle(t,e,s,i,n,o,r,a,c,d,p){let h=-1;const u=zn,y=Mn;let m=null;const g=Sn;if(g.copy(i),g.vsub(s,g),n.conjugate(ve),ve.vmult(g,g),t.pointIsInside(g)){t.worldVerticesNeedsUpdate&&t.computeWorldVertices(s,n),t.worldFaceNormalsNeedsUpdate&&t.computeWorldFaceNormals(n);for(let b=0,f=t.faces.length;b!==f;b++){const x=[t.worldVertices[t.faces[b][0]]],P=t.worldFaceNormals[b];i.vsub(x[0],we);const I=-P.dot(we);if(m===null||Math.abs(I)<Math.abs(m)){if(p)return!0;m=I,h=b,u.copy(P)}}if(h!==-1){const b=this.createContactEquation(a,r,e,t,c,d);u.scale(m,y),y.vadd(i,y),y.vsub(s,y),b.rj.copy(y),u.negate(b.ni),b.ri.set(0,0,0);const f=b.ri,x=b.rj;f.vadd(i,f),f.vsub(a.position,f),x.vadd(s,x),x.vsub(r.position,x),this.result.push(b),this.createFrictionEquationsFromContact(b,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(t,e,s,i,n,o,r,a,c,d,p){return this.convexHeightfield(e,t,i,s,o,n,a,r,c,d,p)}particleCylinder(t,e,s,i,n,o,r,a,c,d,p){return this.convexParticle(e,t,i,s,o,n,a,r,c,d,p)}sphereTrimesh(t,e,s,i,n,o,r,a,c,d,p){const h=Hi,u=ki,y=ji,m=Fi,g=qi,b=Vi,f=Wi,x=Li,P=Oi,I=$i;G.pointToLocalFrame(i,o,s,g);const C=t.radius;f.lowerBound.set(g.x-C,g.y-C,g.z-C),f.upperBound.set(g.x+C,g.y+C,g.z+C),e.getTrianglesInAABB(f,I);const A=Ni,O=t.radius*t.radius;for(let E=0;E<I.length;E++)for(let M=0;M<3;M++)if(e.getVertex(e.indices[I[E]*3+M],A),A.vsub(g,P),P.lengthSquared()<=O){if(x.copy(A),G.pointToWorldFrame(i,o,x,A),A.vsub(s,P),p)return!0;let z=this.createContactEquation(r,a,t,e,c,d);z.ni.copy(P),z.ni.normalize(),z.ri.copy(z.ni),z.ri.scale(t.radius,z.ri),z.ri.vadd(s,z.ri),z.ri.vsub(r.position,z.ri),z.rj.copy(A),z.rj.vsub(a.position,z.rj),this.result.push(z),this.createFrictionEquationsFromContact(z,this.frictionResult)}for(let E=0;E<I.length;E++)for(let M=0;M<3;M++){e.getVertex(e.indices[I[E]*3+M],h),e.getVertex(e.indices[I[E]*3+(M+1)%3],u),u.vsub(h,y),g.vsub(u,b);const z=b.dot(y);g.vsub(h,b);let R=b.dot(y);if(R>0&&z<0&&(g.vsub(h,b),m.copy(y),m.normalize(),R=b.dot(m),m.scale(R,b),b.vadd(h,b),b.distanceTo(g)<t.radius)){if(p)return!0;const j=this.createContactEquation(r,a,t,e,c,d);b.vsub(g,j.ni),j.ni.normalize(),j.ni.scale(t.radius,j.ri),j.ri.vadd(s,j.ri),j.ri.vsub(r.position,j.ri),G.pointToWorldFrame(i,o,b,b),b.vsub(a.position,j.rj),G.vectorToWorldFrame(o,j.ni,j.ni),G.vectorToWorldFrame(o,j.ri,j.ri),this.result.push(j),this.createFrictionEquationsFromContact(j,this.frictionResult)}}const k=Gi,T=Ui,H=Di,F=Ti;for(let E=0,M=I.length;E!==M;E++){e.getTriangleVertices(I[E],k,T,H),e.getNormal(I[E],F),g.vsub(k,b);let z=b.dot(F);if(F.scale(z,b),g.vsub(b,b),z=b.distanceTo(g),X.pointInTriangle(b,k,T,H)&&z<t.radius){if(p)return!0;let R=this.createContactEquation(r,a,t,e,c,d);b.vsub(g,R.ni),R.ni.normalize(),R.ni.scale(t.radius,R.ri),R.ri.vadd(s,R.ri),R.ri.vsub(r.position,R.ri),G.pointToWorldFrame(i,o,b,b),b.vsub(a.position,R.rj),G.vectorToWorldFrame(o,R.ni,R.ni),G.vectorToWorldFrame(o,R.ri,R.ri),this.result.push(R),this.createFrictionEquationsFromContact(R,this.frictionResult)}}I.length=0}planeTrimesh(t,e,s,i,n,o,r,a,c,d,p){const h=new l,u=Bi;u.set(0,0,1),n.vmult(u,u);for(let y=0;y<e.vertices.length/3;y++){e.getVertex(y,h);const m=new l;m.copy(h),G.pointToWorldFrame(i,o,m,h);const g=Ai;if(h.vsub(s,g),u.dot(g)<=0){if(p)return!0;const f=this.createContactEquation(r,a,t,e,c,d);f.ni.copy(u);const x=_i;u.scale(g.dot(u),x),h.vsub(x,x),f.ri.copy(x),f.ri.vsub(r.position,f.ri),f.rj.copy(h),f.rj.vsub(a.position,f.rj),this.result.push(f),this.createFrictionEquationsFromContact(f,this.frictionResult)}}}}const wt=new l,Rt=new l,Ct=new l,Ci=new l,Si=new l,zi=new K,Mi=new K,Bi=new l,Ai=new l,_i=new l,Ti=new l,Oi=new l;new l;const Ni=new l,Li=new l,Hi=new l,ki=new l,ji=new l,Fi=new l,qi=new l,Vi=new l,Gi=new l,Ui=new l,Di=new l,Wi=new it,$i=[],Ft=new l,be=new l,Yi=new l,Xi=new l,Ki=new l;function Zi(w,t,e){let s=null;const i=w.length;for(let n=0;n!==i;n++){const o=w[n],r=Yi;w[(n+1)%i].vsub(o,r);const a=Xi;r.cross(t,a);const c=Ki;e.vsub(o,c);const d=a.dot(c);if(s===null||d>0&&s===!0||d<=0&&s===!1){s===null&&(s=d>0);continue}else return!1}return!0}const qt=new l,Ji=new l,Qi=new l,tn=new l,en=[new l,new l,new l,new l,new l,new l],sn=new l,nn=new l,on=new l,rn=new l,an=new l,ln=new l,cn=new l,hn=new l,dn=new l,pn=new l,un=new l,yn=new l,fn=new l,mn=new l;new l;new l;const gn=new l,bn=new l,vn=new l,wn=new l,xn=new l,Pn=new l,En=new l,In=new l,Rn=new l,Cn=new l,ve=new K,Sn=new l;new l;const zn=new l,we=new l,Mn=new l,Bn=new l,An=new l,_n=[0],Tn=new l,On=new l;class xe{constructor(){this.current=[],this.previous=[]}getKey(t,e){if(e<t){const s=e;e=t,t=s}return t<<16|e}set(t,e){const s=this.getKey(t,e),i=this.current;let n=0;for(;s>i[n];)n++;if(s!==i[n]){for(let o=i.length-1;o>=n;o--)i[o+1]=i[o];i[n]=s}}tick(){const t=this.current;this.current=this.previous,this.previous=t,this.current.length=0}getDiff(t,e){const s=this.current,i=this.previous,n=s.length,o=i.length;let r=0;for(let a=0;a<n;a++){let c=!1;const d=s[a];for(;d>i[r];)r++;c=d===i[r],c||Pe(t,d)}r=0;for(let a=0;a<o;a++){let c=!1;const d=i[a];for(;d>s[r];)r++;c=s[r]===d,c||Pe(e,d)}}}function Pe(w,t){w.push((t&4294901760)>>16,t&65535)}const Kt=(w,t)=>w<t?`${w}-${t}`:`${t}-${w}`;class Nn{constructor(){this.data={keys:[]}}get(t,e){const s=Kt(t,e);return this.data[s]}set(t,e,s){const i=Kt(t,e);this.get(t,e)||this.data.keys.push(i),this.data[i]=s}delete(t,e){const s=Kt(t,e),i=this.data.keys.indexOf(s);i!==-1&&this.data.keys.splice(i,1),delete this.data[s]}reset(){const t=this.data,e=t.keys;for(;e.length>0;){const s=e.pop();delete t[s]}}}class Ln extends ke{constructor(t){t===void 0&&(t={}),super(),this.dt=-1,this.allowSleep=!!t.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=t.quatNormalizeSkip!==void 0?t.quatNormalizeSkip:0,this.quatNormalizeFast=t.quatNormalizeFast!==void 0?t.quatNormalizeFast:!1,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new l,t.gravity&&this.gravity.copy(t.gravity),t.frictionGravity&&(this.frictionGravity=new l,this.frictionGravity.copy(t.frictionGravity)),this.broadphase=t.broadphase!==void 0?t.broadphase:new Fs,this.bodies=[],this.hasActiveBodies=!1,this.solver=t.solver!==void 0?t.solver:new vi,this.constraints=[],this.narrowphase=new Ri(this),this.collisionMatrix=new ae,this.collisionMatrixPrevious=new ae,this.bodyOverlapKeeper=new xe,this.shapeOverlapKeeper=new xe,this.contactmaterials=[],this.contactMaterialTable=new Nn,this.defaultMaterial=new Et("default"),this.defaultContactMaterial=new Pt(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(t,e){return this.contactMaterialTable.get(t.id,e.id)}collisionMatrixTick(){const t=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=t,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(t){this.constraints.push(t)}removeConstraint(t){const e=this.constraints.indexOf(t);e!==-1&&this.constraints.splice(e,1)}rayTest(t,e,s){s instanceof Gt?this.raycastClosest(t,e,{skipBackfaces:!0},s):this.raycastAll(t,e,{skipBackfaces:!0},s)}raycastAll(t,e,s,i){return s===void 0&&(s={}),s.mode=X.ALL,s.from=t,s.to=e,s.callback=i,Zt.intersectWorld(this,s)}raycastAny(t,e,s,i){return s===void 0&&(s={}),s.mode=X.ANY,s.from=t,s.to=e,s.result=i,Zt.intersectWorld(this,s)}raycastClosest(t,e,s,i){return s===void 0&&(s={}),s.mode=X.CLOSEST,s.from=t,s.to=e,s.result=i,Zt.intersectWorld(this,s)}addBody(t){this.bodies.includes(t)||(t.index=this.bodies.length,this.bodies.push(t),t.world=this,t.initPosition.copy(t.position),t.initVelocity.copy(t.velocity),t.timeLastSleepy=this.time,t instanceof S&&(t.initAngularVelocity.copy(t.angularVelocity),t.initQuaternion.copy(t.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=t,this.idToBodyMap[t.id]=t,this.dispatchEvent(this.addBodyEvent))}removeBody(t){t.world=null;const e=this.bodies.length-1,s=this.bodies,i=s.indexOf(t);if(i!==-1){s.splice(i,1);for(let n=0;n!==s.length;n++)s[n].index=n;this.collisionMatrix.setNumObjects(e),this.removeBodyEvent.body=t,delete this.idToBodyMap[t.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(t){return this.idToBodyMap[t]}getShapeById(t){const e=this.bodies;for(let s=0;s<e.length;s++){const i=e[s].shapes;for(let n=0;n<i.length;n++){const o=i[n];if(o.id===t)return o}}return null}addContactMaterial(t){this.contactmaterials.push(t),this.contactMaterialTable.set(t.materials[0].id,t.materials[1].id,t)}removeContactMaterial(t){const e=this.contactmaterials.indexOf(t);e!==-1&&(this.contactmaterials.splice(e,1),this.contactMaterialTable.delete(t.materials[0].id,t.materials[1].id))}fixedStep(t,e){t===void 0&&(t=1/60),e===void 0&&(e=10);const s=J.now()/1e3;if(!this.lastCallTime)this.step(t,void 0,e);else{const i=s-this.lastCallTime;this.step(t,i,e)}this.lastCallTime=s}step(t,e,s){if(s===void 0&&(s=10),e===void 0)this.internalStep(t),this.time+=t;else{this.accumulator+=e;const i=J.now();let n=0;for(;this.accumulator>=t&&n<s&&(this.internalStep(t),this.accumulator-=t,n++,!(J.now()-i>t*1e3)););this.accumulator=this.accumulator%t;const o=this.accumulator/t;for(let r=0;r!==this.bodies.length;r++){const a=this.bodies[r];a.previousPosition.lerp(a.position,o,a.interpolatedPosition),a.previousQuaternion.slerp(a.quaternion,o,a.interpolatedQuaternion),a.previousQuaternion.normalize()}this.time+=e}}internalStep(t){this.dt=t;const e=this.contacts,s=qn,i=Vn,n=this.bodies.length,o=this.bodies,r=this.solver,a=this.gravity,c=this.doProfiling,d=this.profile,p=S.DYNAMIC;let h=-1/0;const u=this.constraints,y=Fn;a.length();const m=a.x,g=a.y,b=a.z;let f=0;for(c&&(h=J.now()),f=0;f!==n;f++){const E=o[f];if(E.type===p){const M=E.force,z=E.mass;M.x+=z*m,M.y+=z*g,M.z+=z*b}}for(let E=0,M=this.subsystems.length;E!==M;E++)this.subsystems[E].update();c&&(h=J.now()),s.length=0,i.length=0,this.broadphase.collisionPairs(this,s,i),c&&(d.broadphase=J.now()-h);let x=u.length;for(f=0;f!==x;f++){const E=u[f];if(!E.collideConnected)for(let M=s.length-1;M>=0;M-=1)(E.bodyA===s[M]&&E.bodyB===i[M]||E.bodyB===s[M]&&E.bodyA===i[M])&&(s.splice(M,1),i.splice(M,1))}this.collisionMatrixTick(),c&&(h=J.now());const P=jn,I=e.length;for(f=0;f!==I;f++)P.push(e[f]);e.length=0;const C=this.frictionEquations.length;for(f=0;f!==C;f++)y.push(this.frictionEquations[f]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(s,i,this,e,P,this.frictionEquations,y),c&&(d.narrowphase=J.now()-h),c&&(h=J.now()),f=0;f<this.frictionEquations.length;f++)r.addEquation(this.frictionEquations[f]);const A=e.length;for(let E=0;E!==A;E++){const M=e[E],z=M.bi,R=M.bj,$=M.si,j=M.sj;let q;if(z.material&&R.material?q=this.getContactMaterial(z.material,R.material)||this.defaultContactMaterial:q=this.defaultContactMaterial,q.friction,z.material&&R.material&&(z.material.friction>=0&&R.material.friction>=0&&z.material.friction*R.material.friction,z.material.restitution>=0&&R.material.restitution>=0&&(M.restitution=z.material.restitution*R.material.restitution)),r.addEquation(M),z.allowSleep&&z.type===S.DYNAMIC&&z.sleepState===S.SLEEPING&&R.sleepState===S.AWAKE&&R.type!==S.STATIC){const tt=R.velocity.lengthSquared()+R.angularVelocity.lengthSquared(),Q=R.sleepSpeedLimit**2;tt>=Q*2&&(z.wakeUpAfterNarrowphase=!0)}if(R.allowSleep&&R.type===S.DYNAMIC&&R.sleepState===S.SLEEPING&&z.sleepState===S.AWAKE&&z.type!==S.STATIC){const tt=z.velocity.lengthSquared()+z.angularVelocity.lengthSquared(),Q=z.sleepSpeedLimit**2;tt>=Q*2&&(R.wakeUpAfterNarrowphase=!0)}this.collisionMatrix.set(z,R,!0),this.collisionMatrixPrevious.get(z,R)||(Bt.body=R,Bt.contact=M,z.dispatchEvent(Bt),Bt.body=z,R.dispatchEvent(Bt)),this.bodyOverlapKeeper.set(z.id,R.id),this.shapeOverlapKeeper.set($.id,j.id)}for(this.emitContactEvents(),c&&(d.makeContactConstraints=J.now()-h,h=J.now()),f=0;f!==n;f++){const E=o[f];E.wakeUpAfterNarrowphase&&(E.wakeUp(),E.wakeUpAfterNarrowphase=!1)}for(x=u.length,f=0;f!==x;f++){const E=u[f];E.update();for(let M=0,z=E.equations.length;M!==z;M++){const R=E.equations[M];r.addEquation(R)}}r.solve(t,this),c&&(d.solve=J.now()-h),r.removeAllEquations();const O=Math.pow;for(f=0;f!==n;f++){const E=o[f];if(E.type&p){const M=O(1-E.linearDamping,t),z=E.velocity;z.scale(M,z);const R=E.angularVelocity;if(R){const $=O(1-E.angularDamping,t);R.scale($,R)}}}this.dispatchEvent(kn),c&&(h=J.now());const T=this.stepnumber%(this.quatNormalizeSkip+1)===0,H=this.quatNormalizeFast;for(f=0;f!==n;f++)o[f].integrate(t,T,H);this.clearForces(),this.broadphase.dirty=!0,c&&(d.integrate=J.now()-h),this.stepnumber+=1,this.dispatchEvent(Hn);let F=!0;if(this.allowSleep)for(F=!1,f=0;f!==n;f++){const E=o[f];E.sleepTick(this.time),E.sleepState!==S.SLEEPING&&(F=!0)}this.hasActiveBodies=F}emitContactEvents(){const t=this.hasAnyEventListener("beginContact"),e=this.hasAnyEventListener("endContact");if((t||e)&&this.bodyOverlapKeeper.getDiff(dt,pt),t){for(let n=0,o=dt.length;n<o;n+=2)At.bodyA=this.getBodyById(dt[n]),At.bodyB=this.getBodyById(dt[n+1]),this.dispatchEvent(At);At.bodyA=At.bodyB=null}if(e){for(let n=0,o=pt.length;n<o;n+=2)_t.bodyA=this.getBodyById(pt[n]),_t.bodyB=this.getBodyById(pt[n+1]),this.dispatchEvent(_t);_t.bodyA=_t.bodyB=null}dt.length=pt.length=0;const s=this.hasAnyEventListener("beginShapeContact"),i=this.hasAnyEventListener("endShapeContact");if((s||i)&&this.shapeOverlapKeeper.getDiff(dt,pt),s){for(let n=0,o=dt.length;n<o;n+=2){const r=this.getShapeById(dt[n]),a=this.getShapeById(dt[n+1]);ut.shapeA=r,ut.shapeB=a,r&&(ut.bodyA=r.body),a&&(ut.bodyB=a.body),this.dispatchEvent(ut)}ut.bodyA=ut.bodyB=ut.shapeA=ut.shapeB=null}if(i){for(let n=0,o=pt.length;n<o;n+=2){const r=this.getShapeById(pt[n]),a=this.getShapeById(pt[n+1]);yt.shapeA=r,yt.shapeB=a,r&&(yt.bodyA=r.body),a&&(yt.bodyB=a.body),this.dispatchEvent(yt)}yt.bodyA=yt.bodyB=yt.shapeA=yt.shapeB=null}}clearForces(){const t=this.bodies,e=t.length;for(let s=0;s!==e;s++){const i=t[s];i.force,i.torque,i.force.set(0,0,0),i.torque.set(0,0,0)}}}new it;const Zt=new X,J=globalThis.performance||{};if(!J.now){let w=Date.now();J.timing&&J.timing.navigationStart&&(w=J.timing.navigationStart),J.now=()=>Date.now()-w}new l;const Hn={type:"postStep"},kn={type:"preStep"},Bt={type:S.COLLIDE_EVENT_NAME,body:null,contact:null},jn=[],Fn=[],qn=[],Vn=[],dt=[],pt=[],At={type:"beginContact",bodyA:null,bodyB:null},_t={type:"endContact",bodyA:null,bodyB:null},ut={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},yt={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null};class Gn{constructor(){this.world=new Ln({gravity:new l(0,U.gravity,0)}),this.world.broadphase=new St(this.world),this.world.allowSleep=!0,this.COLLISION_GROUPS=U.collisionGroups,this.setupMaterials(),this.createFloor(),this.bodies=new Map,this.onCollision=null}setupMaterials(){this.playerMaterial=new Et("player"),this.handMaterial=new Et("hand"),this.groundMaterial=new Et("ground"),this.world.addContactMaterial(new Pt(this.playerMaterial,this.handMaterial,{friction:.5,restitution:.1})),this.world.addContactMaterial(new Pt(this.playerMaterial,this.groundMaterial,{friction:.6,restitution:.2})),this.world.addContactMaterial(new Pt(this.playerMaterial,this.playerMaterial,{friction:.4,restitution:.3}))}createFloor(){const t=new gi,e=new S({mass:0,material:this.groundMaterial,collisionFilterGroup:this.COLLISION_GROUPS.ENVIRONMENT,collisionFilterMask:this.COLLISION_GROUPS.PLAYER});e.addShape(t),e.quaternion.setFromEuler(-Math.PI/2,0,0),this.world.addBody(e),this.groundBody=e}step(t){this.world.step(U.fixedTimeStep,t,U.maxSubSteps)}addBody(t,e){this.bodies.set(t,e),this.world.addBody(e)}removeBody(t){const e=this.bodies.get(t);e&&(this.world.removeBody(e),this.bodies.delete(t))}getBody(t){return this.bodies.get(t)}getBodyId(t){for(const[e,s]of this.bodies)if(s===t)return e;return null}setupCollisionListener(t){this.onCollision=t,this.world.addEventListener("beginContact",e=>{this.onCollision&&this.onCollision(e)})}}class Ee{constructor(t,e){this.physicsWorld=t,this.handedness=e,this.virtualMass=U.hand.virtualMass,this.isActive=!1,this.fingertipIndices={thumb:4,index:9,middle:14,ring:19,pinky:24},this.fingertipBodies=new Map,this.fingertipVelocities=new Map,this.fingertipPrevPositions=new Map,this.fingertipHasValidPrev=new Map,this.createFingertipBodies()}createFingertipBodies(){const t=U.hand.fingertipRadius;for(const[e,s]of Object.entries(this.fingertipIndices)){const i=new mi(t),n=new S({mass:0,type:S.KINEMATIC,shape:i,material:this.physicsWorld.handMaterial,collisionFilterGroup:this.physicsWorld.COLLISION_GROUPS.VR_HAND,collisionFilterMask:this.physicsWorld.COLLISION_GROUPS.PLAYER,collisionResponse:!0});n.position.set(0,-100,0),this.physicsWorld.addBody(`hand_${this.handedness}_${e}`,n),this.fingertipBodies.set(e,n),this.fingertipVelocities.set(e,new V),this.fingertipPrevPositions.set(e,new V),this.fingertipHasValidPrev.set(e,!1)}}update(t,e,s){var o;if(!t||t.length<25){this.isActive=!1;for(const r of this.fingertipBodies.values())r.position.set(0,-100,0);for(const r of Object.keys(this.fingertipIndices))this.fingertipHasValidPrev.set(r,!1),(o=this.fingertipVelocities.get(r))==null||o.set(0,0,0);return}this.isActive=!0;const i=U.hand.nearPinchThreshold,n=e<i;for(const[r,a]of Object.entries(this.fingertipIndices)){const c=t[a],d=this.fingertipBodies.get(r),p=this.fingertipPrevPositions.get(r),h=this.fingertipVelocities.get(r);if(!c){d.position.set(0,-100,0),this.fingertipHasValidPrev.set(r,!1),h.set(0,0,0);continue}if(n&&(r==="thumb"||r==="index")){d.position.set(0,-100,0),this.fingertipHasValidPrev.set(r,!1),h.set(0,0,0);continue}this.fingertipHasValidPrev.get(r)&&s>0&&(h.set((c.x-p.x)/s,(c.y-p.y)/s,(c.z-p.z)/s),h.length()<.01&&h.set(0,0,0)),p.set(c.x,c.y,c.z),this.fingertipHasValidPrev.set(r,!0),d.position.set(c.x,c.y,c.z)}}getFingertipVelocity(t){var e;return((e=this.fingertipVelocities.get(t))==null?void 0:e.clone())||new V}getVelocity(){let t=new V,e=0;for(const s of this.fingertipVelocities.values()){const i=s.length();i>e&&(e=i,t=s.clone())}return t}getSpeed(){return this.getVelocity().length()}getMomentum(){return this.getVelocity().multiplyScalar(this.virtualMass)}getImpactForce(){return this.getMomentum().length()}getFingertipBody(t){return this.fingertipBodies.get(t)}reset(){for(const[t]of this.fingertipBodies)this.fingertipBodies.get(t).position.set(0,-100,0),this.fingertipVelocities.get(t).set(0,0,0),this.fingertipPrevPositions.get(t).set(0,0,0),this.fingertipHasValidPrev.set(t,!1);this.isActive=!1}dispose(){for(const[t]of this.fingertipBodies)this.physicsWorld.removeBody(`hand_${this.handedness}_${t}`);this.fingertipBodies.clear(),this.fingertipVelocities.clear(),this.fingertipPrevPositions.clear(),this.fingertipHasValidPrev.clear()}}class Un{constructor(t,e){this.physicsWorld=t,this.playerId=e,this.mode="kinematic",this.meshOffset=new V(0,U.player.height/2,0),this.body=this.createBody(),t.addBody(`player_${e}`,this.body)}createBody(){const t=U.player,e=new l(t.width/2,t.height/2,t.depth/2),s=new Ot(e),i=new S({mass:t.mass,type:S.KINEMATIC,material:this.physicsWorld.playerMaterial,linearDamping:t.linearDamping,angularDamping:t.angularDamping,fixedRotation:!0,collisionFilterGroup:this.physicsWorld.COLLISION_GROUPS.PLAYER,collisionFilterMask:this.physicsWorld.COLLISION_GROUPS.PLAYER|this.physicsWorld.COLLISION_GROUPS.VR_HAND|this.physicsWorld.COLLISION_GROUPS.ENVIRONMENT});return i.addShape(s),i}setMode(t){this.mode!==t&&(this.mode=t,t==="dynamic"?(this.body.type=S.DYNAMIC,this.body.mass=U.player.mass,this.body.updateMassProperties(),this.body.wakeUp()):(this.body.type=S.KINEMATIC,this.body.velocity.set(0,0,0),this.body.angularVelocity.set(0,0,0)))}setPosition(t,e,s){this.body.position.set(t,e+this.meshOffset.y,s)}setPositionFromMesh(t){this.body.position.set(t.position.x,t.position.y+this.meshOffset.y,t.position.z)}applyImpulse(t){this.mode==="dynamic"&&this.body.applyImpulse(new l(t.x,t.y,t.z),this.body.position)}setVelocity(t){this.body.velocity.set(t.x,t.y,t.z)}disableHandCollision(){this.body.collisionFilterMask=this.physicsWorld.COLLISION_GROUPS.PLAYER|this.physicsWorld.COLLISION_GROUPS.ENVIRONMENT}enableHandCollision(){this.body.collisionFilterMask=this.physicsWorld.COLLISION_GROUPS.PLAYER|this.physicsWorld.COLLISION_GROUPS.VR_HAND|this.physicsWorld.COLLISION_GROUPS.ENVIRONMENT}getVelocity(){return new V(this.body.velocity.x,this.body.velocity.y,this.body.velocity.z)}getSpeed(){return this.getVelocity().length()}getPosition(){return new V(this.body.position.x,this.body.position.y-this.meshOffset.y,this.body.position.z)}getRotation(){return{x:this.body.quaternion.x,y:this.body.quaternion.y,z:this.body.quaternion.z,w:this.body.quaternion.w}}resetRotation(){this.body.quaternion.set(0,0,0,1),this.body.angularVelocity.set(0,0,0)}syncToMesh(t){this.mode==="dynamic"&&(t.position.set(this.body.position.x,this.body.position.y-this.meshOffset.y,this.body.position.z),t.quaternion.set(this.body.quaternion.x,this.body.quaternion.y,this.body.quaternion.z,this.body.quaternion.w))}syncFromMesh(t){this.mode==="kinematic"&&this.body.position.set(t.position.x,t.position.y+this.meshOffset.y,t.position.z)}getState(){return{position:{x:this.body.position.x,y:this.body.position.y,z:this.body.position.z},rotation:{x:this.body.quaternion.x,y:this.body.quaternion.y,z:this.body.quaternion.z,w:this.body.quaternion.w},velocity:{x:this.body.velocity.x,y:this.body.velocity.y,z:this.body.velocity.z},angularVelocity:{x:this.body.angularVelocity.x,y:this.body.angularVelocity.y,z:this.body.angularVelocity.z}}}dispose(){this.physicsWorld.removeBody(`player_${this.playerId}`)}}function $e(w){try{const t=JSON.stringify({message:w});navigator.sendBeacon("/api/log",t)}catch{fetch("/api/log",{method:"POST",body:JSON.stringify({message:w}),keepalive:!0}).catch(()=>{})}}function gt(w){$e(w),console.log("[Debug]",w)}function Dn(w,t){const e=t?`: ${t.message||t}`:"",s=`ERROR: ${w}${e}`;$e(s),console.error("[Debug Error]",w,t)}class Wn{constructor(t,e){this.physicsWorld=t,this.handPhysics=e,this.onPlayerRagdoll=null,this.isPlayerHeld=null,this.isBlockHeldByHand=null,this.pendingReenables=new Map,this.setupCollisionListener()}setupCollisionListener(){this.physicsWorld.world.addEventListener("beginContact",t=>{this.handleCollision(t)})}handleCollision(t){const e=t.bodyA,s=t.bodyB,i=this.physicsWorld.getBodyId(e),n=this.physicsWorld.getBodyId(s);!i||!n||(i.startsWith("hand_")&&n.startsWith("player_")?this.handleHandPlayerCollision(i,n,e,s):n.startsWith("hand_")&&i.startsWith("player_")?this.handleHandPlayerCollision(n,i,s,e):i.startsWith("hand_")&&n.startsWith("block_")?this.handleHandBlockCollision(i,n,e,s):n.startsWith("hand_")&&i.startsWith("block_")?this.handleHandBlockCollision(n,i,s,e):i.startsWith("player_")&&n.startsWith("player_")&&this.handlePlayerPlayerCollision(i,n,e,s))}parseHandId(t){const e=t.split("_");return e.length>=3?{handedness:e[1],finger:e[2]}:{handedness:e[1]||"unknown",finger:null}}handleHandPlayerCollision(t,e,s,i){const n=e.replace("player_","");if(this.isPlayerHeld&&this.isPlayerHeld(n))return;const{handedness:o,finger:r}=this.parseHandId(t),a=this.handPhysics[o];if(!a||!a.isActive)return;if(gt(`Collision: ${o}/${r} -> ${n}`),a.getImpactForce()>=U.forces.ragdollThreshold){const d=a.getVelocity(),p=d.clone().multiplyScalar(a.virtualMass*U.forces.impulseMultiplier);p.y+=Math.abs(p.length())*U.forces.upwardImpulseBoost,this.onPlayerRagdoll&&this.onPlayerRagdoll(n,p,d,"hand",t)}}handleHandBlockCollision(t,e,s,i){if(!s||!i)return;const{handedness:n}=this.parseHandId(t),o=n==="left"?0:1;if(this.isBlockHeldByHand&&this.isBlockHeldByHand(e,o))return;const r=this.handPhysics[n];if(!r||!r.isActive)return;const a=r.getVelocity(),c=a.length();if(!isFinite(c)||c<.3)return;const p=20;c>p&&a.multiplyScalar(p/c);const h=U.forces.impulseMultiplier,u=new l(a.x*r.virtualMass*h,a.y*r.virtualMass*h,a.z*r.virtualMass*h);if(!isFinite(u.x)||!isFinite(u.y)||!isFinite(u.z))return;i.applyImpulse(u,i.position);const y=s.position,m=i.position,b=new l(y.x-m.x,y.y-m.y,y.z-m.z).cross(u);b.scale(.5,b),isFinite(b.x)&&isFinite(b.y)&&isFinite(b.z)&&i.angularVelocity.vadd(b,i.angularVelocity),i.wakeUp()}handlePlayerPlayerCollision(t,e,s,i){const n=t.replace("player_",""),o=e.replace("player_","");if(this.isPlayerHeld&&(this.isPlayerHeld(n)||this.isPlayerHeld(o)))return;const r=new V(s.velocity.x,s.velocity.y,s.velocity.z),a=new V(i.velocity.x,i.velocity.y,i.velocity.z),c=s.mass||U.player.mass,d=i.mass||U.player.mass,p=r.length()*c,h=a.length()*d;if(p>=U.forces.chainReactionThreshold){const u=r.clone().multiplyScalar(c*U.forces.impulseMultiplier);u.y+=Math.abs(u.length())*U.forces.upwardImpulseBoost*.5,this.onPlayerRagdoll&&this.onPlayerRagdoll(o,u,r,"player",n)}if(h>=U.forces.chainReactionThreshold){const u=a.clone().multiplyScalar(d*U.forces.impulseMultiplier);u.y+=Math.abs(u.length())*U.forces.upwardImpulseBoost*.5,this.onPlayerRagdoll&&this.onPlayerRagdoll(n,u,a,"player",o)}}scheduleHandCollisionReenable(t,e=150){this.pendingReenables.has(t)&&clearTimeout(this.pendingReenables.get(t)),t.disableHandCollision&&t.disableHandCollision();const s=setTimeout(()=>{t.enableHandCollision&&t.enableHandCollision(),this.pendingReenables.delete(t)},e);this.pendingReenables.set(t,s)}cancelPendingReenable(t){this.pendingReenables.has(t)&&(clearTimeout(this.pendingReenables.get(t)),this.pendingReenables.delete(t),t.enableHandCollision&&t.enableHandCollision())}}class $n{constructor(){this.players=new Map,this.objects=new Map,this.vrHandData=null,this.vrHeadData=null,this.heldPlayerId=null,this.cameraTransformData=null,this.physicsWorld=null,this.handPhysics={left:null,right:null},this.playerPhysics=new Map,this.playerStateMachines=new Map,this.collisionHandler=null,this.physicsInitialized=!1,this.stateUpdateInterval=null,this.previousPlayerPositions=new Map,this.previousObjectPositions=new Map,this.positionChangeThreshold=.001,this.fullStateBroadcastCounter=0,this.fullStateBroadcastInterval=20,this.onPlayerPhysicsCreated=null}initialize(){_.on(L.PLAYER_JOIN,t=>this.onPlayerJoin(t)),_.on(L.PLAYER_LEAVE,t=>this.onPlayerLeave(t)),_.on(L.PLAYER_STATE,t=>this.onPlayerState(t)),_.on(L.GRAB_REQUEST,t=>this.onGrabRequest(t)),_.on(L.OBJECT_RELEASE,t=>this.onObjectRelease(t)),_.on(L.OBJECT_UPDATE,t=>this.onObjectUpdate(t)),this.stateUpdateInterval=setInterval(()=>this.broadcastWorldState(),50)}initializePhysics(){this.physicsInitialized||(this.physicsWorld=new Gn,this.handPhysics.left=new Ee(this.physicsWorld,"left"),this.handPhysics.right=new Ee(this.physicsWorld,"right"),this.collisionHandler=new Wn(this.physicsWorld,this.handPhysics),this.collisionHandler.onPlayerRagdoll=(t,e,s,i,n)=>{this.triggerPlayerRagdoll(t,e,s,i,n)},this.collisionHandler.isPlayerHeld=t=>this.heldPlayerId===t,this.physicsInitialized=!0,console.log("Physics system initialized"))}onPlayerJoin(t){console.log("Player joined:",t.playerId),this.players.set(t.playerId,{id:t.playerId,position:{x:0,y:.08,z:.5},rotation:0,type:"pc",state:st.WALKING}),this.physicsInitialized&&this.createPlayerPhysics(t.playerId),this.sendInitialState(t.playerId)}createPlayerPhysics(t,e=null){if(!this.physicsWorld)return;const s=new Un(this.physicsWorld,t);this.playerPhysics.set(t,s);const i=new Ze(t,s,e);i.onStateChange=(o,r,a,c)=>{this.onPlayerStateChange(o,r,a,c)},this.playerStateMachines.set(t,i);const n=this.players.get(t);return n&&s.setPosition(n.position.x,0,n.position.z),this.onPlayerPhysicsCreated&&this.onPlayerPhysicsCreated(t,s,i),{physicsBody:s,stateMachine:i}}setPlayerAnimationController(t,e){const s=this.playerStateMachines.get(t);s&&(s.animationController=e)}onPlayerLeave(t){console.log("Player left:",t.playerId),this.players.delete(t.playerId);const e=this.playerPhysics.get(t.playerId);e&&(e.dispose(),this.playerPhysics.delete(t.playerId)),this.playerStateMachines.delete(t.playerId),this.objects.forEach((s,i)=>{s.heldBy===t.playerId&&(s.heldBy=null)}),this.heldPlayerId===t.playerId&&(this.heldPlayerId=null)}onPlayerState(t){const e=this.players.get(t.senderId);if(e){e.position=t.position,e.rotation=t.rotation;const s=this.playerStateMachines.get(t.senderId),i=this.playerPhysics.get(t.senderId);s&&i&&s.state===st.WALKING&&i.setPosition(t.position.x,0,t.position.z)}}onPlayerStateChange(t,e,s,i){const n=this.players.get(t);n&&(n.state=s),s===st.RAGDOLL?_.broadcast({type:L.RAGDOLL_TRIGGERED,playerId:t,impulse:i.impulse?{x:i.impulse.x,y:i.impulse.y,z:i.impulse.z}:null,sourceType:i.sourceType,sourceId:i.sourceId}):s===st.RECOVERING&&_.broadcast({type:L.RAGDOLL_RECOVERY,playerId:t})}onGrabRequest(t){const e=this.objects.get(t.objectId);if(!e)return;const s=e.heldBy===null;s&&(e.heldBy=t.senderId),_.sendTo(t.senderId,{type:L.GRAB_RESPONSE,objectId:t.objectId,granted:s})}onObjectRelease(t){const e=this.objects.get(t.objectId);e&&e.heldBy===t.senderId&&(e.heldBy=null,e.position=t.position,e.rotation=t.rotation)}onObjectUpdate(t){const e=this.objects.get(t.objectId);e&&e.heldBy===t.senderId&&(e.position=t.position)}sendInitialState(t){const e={type:"initial_state",players:Array.from(this.players.values()),objects:Array.from(this.objects.values())};_.sendTo(t,e)}registerObject(t,e,s){this.objects.set(t,{id:t,position:{x:e.x,y:e.y,z:e.z},rotation:{x:s.x,y:s.y,z:s.z},heldBy:null})}updateObjectPosition(t,e,s){const i=this.objects.get(t);i&&(i.position={x:e.x,y:e.y,z:e.z},i.rotation={x:s.x,y:s.y,z:s.z})}setObjectHeldBy(t,e){const s=this.objects.get(t);s&&(s.heldBy=e)}releaseObject(t){const e=this.objects.get(t);e&&(e.heldBy=null)}updatePhysics(t,e){var s,i;if(this.physicsInitialized){if((s=e==null?void 0:e.left)!=null&&s.joints&&e.left.joints.length>=25){const n=this.calculatePinchDistance(e.left.joints);this.handPhysics.left.update(e.left.joints,n,t)}else this.handPhysics.left.update(null,1/0,t);if((i=e==null?void 0:e.right)!=null&&i.joints&&e.right.joints.length>=25){const n=this.calculatePinchDistance(e.right.joints);this.handPhysics.right.update(e.right.joints,n,t)}else this.handPhysics.right.update(null,1/0,t);this.physicsWorld.step(t),this.playerStateMachines.forEach(n=>n.update(t))}}calculatePinchDistance(t){const e=t[4],s=t[9];return!e||!s?1/0:Math.sqrt((e.x-s.x)**2+(e.y-s.y)**2+(e.z-s.z)**2)}triggerPlayerRagdoll(t,e,s,i="hand",n=null){const o=this.playerStateMachines.get(t);if(!o){console.warn(`Cannot trigger ragdoll for player ${t}: no state machine`);return}try{o.triggerRagdoll(e,s)}catch(r){console.error(`Error triggering ragdoll for player ${t}:`,r)}}pickupPlayer(t){try{gt(`HM: pickupPlayer ${t}`);const e=this.playerStateMachines.get(t),s=this.playerPhysics.get(t);return!e||!s?(gt(`WARN: physics not ready for ${t}`),!1):this.heldPlayerId?(gt(`WARN: already holding ${this.heldPlayerId}`),!1):(this.heldPlayerId=t,gt(`HM: heldPlayerId = ${t}`),gt("HM: triggerHeld()"),e.triggerHeld(),gt("HM: triggerHeld done"),_.sendTo(t,{type:L.PLAYER_PICKUP,heldBy:"host"}),gt("HM: pickup complete"),!0)}catch(e){return Dn("pickupPlayer failed",e),!1}}releasePlayer(t=null){if(!this.heldPlayerId)return;const e=this.heldPlayerId;this.heldPlayerId=null;const s=this.playerPhysics.get(e);s&&this.collisionHandler.scheduleHandCollisionReenable(s);const i=this.playerStateMachines.get(e);if(i)try{i.triggerRelease(t)}catch(n){console.error(`Error releasing player ${e}:`,n)}_.sendTo(e,{type:L.PLAYER_RELEASE,throwVelocity:t?{x:t.x,y:t.y,z:t.z}:null})}updateHeldPlayerPosition(t){if(this.heldPlayerId){const e=this.playerPhysics.get(this.heldPlayerId);e&&e.setPosition(t.x,t.y,t.z),_.sendTo(this.heldPlayerId,{type:L.PLAYER_POSITION,position:t})}}getHeldPlayerId(){return this.heldPlayerId}getPlayerPhysicsBody(t){return this.playerPhysics.get(t)}getPlayerStateMachine(t){return this.playerStateMachines.get(t)}updateVRHands(t){this.vrHandData=t}updateVRHead(t){this.vrHeadData=t}setCameraTransform(t){this.cameraTransformData=t}getHostStats(){var t,e;return{playerCount:this.players.size,objectCount:this.objects.size,physicsBodyCount:((e=(t=this.physicsWorld)==null?void 0:t.bodies)==null?void 0:e.size)||0,heldPlayerId:this.heldPlayerId,hasVRHandData:this.vrHandData!==null,hasVRHeadData:this.vrHeadData!==null}}_hasPositionChanged(t,e){if(!t||!e)return!0;const s=Math.abs((t.x||0)-(e.x||0)),i=Math.abs((t.y||0)-(e.y||0)),n=Math.abs((t.z||0)-(e.z||0));return s>this.positionChangeThreshold||i>this.positionChangeThreshold||n>this.positionChangeThreshold}broadcastWorldState(){this.fullStateBroadcastCounter++;const t=this.fullStateBroadcastCounter>=this.fullStateBroadcastInterval;t&&(this.fullStateBroadcastCounter=0);const e=[];this.players.forEach((i,n)=>{const o=this.playerStateMachines.get(n),r=this.playerPhysics.get(n);if(r){const a=r.getState(),c=this.previousPlayerPositions.get(n);(t||this._hasPositionChanged(c,a.position))&&(e.push({id:n,state:o?o.state:st.WALKING,position:a.position,rotation:a.rotation,velocity:a.velocity}),this.previousPlayerPositions.set(n,{...a.position}))}});const s=[];if(this.objects.forEach((i,n)=>{const o=this.previousObjectPositions.get(n);(t||this._hasPositionChanged(o,i.position))&&(s.push(i),i.position&&this.previousObjectPositions.set(n,{...i.position}))}),t||e.length>0||s.length>0){const i={type:L.WORLD_STATE,timestamp:Date.now(),players:t?Array.from(this.players.values()):[],objects:s,vrHead:this.vrHeadData,vrHands:this.vrHandData,playerPhysics:e,cameraTransform:this.cameraTransformData,isFullState:t};_.broadcast(i)}}broadcastHandTracking(){if(!this.vrHandData)return;const t={type:L.HAND_TRACKING,timestamp:Date.now(),hands:this.vrHandData};_.broadcast(t)}cleanup(){this.stateUpdateInterval&&clearInterval(this.stateUpdateInterval),this.playerPhysics.forEach(t=>t.dispose()),this.playerPhysics.clear(),this.playerStateMachines.clear()}}const W=new $n;class Yn{constructor(){this.container=null,this.playersPanel=null,this.physicsPanel=null,this.networkPanel=null,this.objectsPanel=null,this.eventLog=null,this.errorLog=null,this.maxLogEntries=50,this.createUI()}createUI(){this.container=document.createElement("div"),this.container.id="dashboard",this.container.innerHTML=`
      <div class="dashboard-header">
        <h1>VR Game Host Dashboard</h1>
        <div class="header-status">
          <span id="dash-status" class="status-indicator status-waiting">Waiting for players...</span>
          <span id="dash-uptime">Uptime: 0:00</span>
        </div>
      </div>

      <div class="dashboard-grid">
        <div class="panel panel-players">
          <h2>Players <span id="player-count">(0)</span></h2>
          <div id="players-list" class="panel-content"></div>
        </div>

        <div class="panel panel-physics">
          <h2>Physics Stats</h2>
          <div class="panel-content">
            <div class="stat-row">
              <span class="stat-label">Bodies:</span>
              <span id="stat-bodies" class="stat-value">0</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">Step Time:</span>
              <span id="stat-step-time" class="stat-value">0ms</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">Collisions:</span>
              <span id="stat-collisions" class="stat-value">0</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">Update Rate:</span>
              <span id="stat-update-rate" class="stat-value">0 Hz</span>
            </div>
          </div>
        </div>

        <div class="panel panel-network">
          <h2>Network</h2>
          <div class="panel-content">
            <div class="stat-row">
              <span class="stat-label">VR Client:</span>
              <span id="stat-vr-client" class="stat-value">Not connected</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">VR Latency:</span>
              <span id="stat-vr-latency" class="stat-value">--</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">Messages/s:</span>
              <span id="stat-msg-rate" class="stat-value">0</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">Bandwidth:</span>
              <span id="stat-bandwidth" class="stat-value">0 KB/s</span>
            </div>
          </div>
        </div>

        <div class="panel panel-objects">
          <h2>Objects <span id="object-count">(0)</span></h2>
          <div id="objects-list" class="panel-content"></div>
        </div>

        <div class="panel panel-events">
          <h2>Event Log</h2>
          <div id="event-log" class="panel-content log-content"></div>
        </div>

        <div class="panel panel-errors">
          <h2>Errors</h2>
          <div id="error-log" class="panel-content log-content"></div>
        </div>
      </div>
    `;const t=document.createElement("style");t.textContent=`
      #dashboard {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #0f0f1a;
        font-family: 'SF Mono', 'Consolas', monospace;
        color: #e0e0e0;
        overflow: auto;
        padding: 20px;
        box-sizing: border-box;
      }

      .dashboard-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid #2a2a3a;
      }

      .dashboard-header h1 {
        margin: 0;
        font-size: 20px;
        font-weight: 600;
        color: #fff;
      }

      .header-status {
        display: flex;
        gap: 20px;
        align-items: center;
        font-size: 13px;
      }

      .status-indicator {
        padding: 4px 12px;
        border-radius: 12px;
        font-weight: 500;
      }

      .status-waiting {
        background: #3d3d00;
        color: #ffd700;
      }

      .status-active {
        background: #003d00;
        color: #4ade80;
      }

      #dash-uptime {
        color: #888;
      }

      .dashboard-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: auto auto;
        gap: 15px;
        max-width: 1400px;
      }

      .panel {
        background: #1a1a2e;
        border-radius: 8px;
        border: 1px solid #2a2a3a;
        overflow: hidden;
      }

      .panel h2 {
        margin: 0;
        padding: 12px 15px;
        font-size: 13px;
        font-weight: 600;
        background: #252538;
        border-bottom: 1px solid #2a2a3a;
        color: #aaa;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .panel h2 span {
        font-weight: normal;
        color: #666;
      }

      .panel-content {
        padding: 12px 15px;
        max-height: 200px;
        overflow-y: auto;
      }

      .panel-events, .panel-errors {
        grid-column: span 1;
      }

      .stat-row {
        display: flex;
        justify-content: space-between;
        padding: 6px 0;
        border-bottom: 1px solid #252538;
      }

      .stat-row:last-child {
        border-bottom: none;
      }

      .stat-label {
        color: #888;
      }

      .stat-value {
        font-weight: 500;
        color: #4ade80;
      }

      .player-item, .object-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 10px;
        margin-bottom: 6px;
        background: #252538;
        border-radius: 4px;
        font-size: 12px;
      }

      .player-item .player-id {
        font-weight: 500;
      }

      .player-item .player-type {
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 10px;
        font-weight: 600;
        text-transform: uppercase;
      }

      .player-type.vr {
        background: #5b21b6;
        color: #c4b5fd;
      }

      .player-type.pc {
        background: #1e40af;
        color: #93c5fd;
      }

      .player-item .player-pos {
        color: #666;
        font-size: 11px;
      }

      .player-item .player-state {
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 10px;
      }

      .state-walking { background: #065f46; color: #6ee7b7; }
      .state-held { background: #7c2d12; color: #fdba74; }
      .state-ragdoll { background: #7f1d1d; color: #fca5a5; }
      .state-recovering { background: #713f12; color: #fcd34d; }

      .object-item .object-id {
        font-weight: 500;
      }

      .object-item .object-status {
        color: #666;
        font-size: 11px;
      }

      .object-status.held {
        color: #fbbf24;
      }

      .log-content {
        font-size: 11px;
        max-height: 180px;
      }

      .log-entry {
        padding: 4px 0;
        border-bottom: 1px solid #252538;
        display: flex;
        gap: 10px;
      }

      .log-entry:last-child {
        border-bottom: none;
      }

      .log-time {
        color: #666;
        flex-shrink: 0;
      }

      .log-msg {
        color: #e0e0e0;
      }

      .log-entry.error .log-msg {
        color: #f87171;
      }

      .log-entry.warn .log-msg {
        color: #fbbf24;
      }

      .empty-state {
        color: #555;
        text-align: center;
        padding: 20px;
        font-size: 12px;
      }
    `,document.head.appendChild(t),document.body.appendChild(this.container),this.playersPanel=document.getElementById("players-list"),this.objectsPanel=document.getElementById("objects-list"),this.eventLog=document.getElementById("event-log"),this.errorLog=document.getElementById("error-log"),this.playersPanel.innerHTML='<div class="empty-state">No players connected</div>',this.objectsPanel.innerHTML='<div class="empty-state">No objects</div>',this.eventLog.innerHTML='<div class="empty-state">No events yet</div>',this.errorLog.innerHTML='<div class="empty-state">No errors</div>'}updatePlayers(t,e){if(document.getElementById("player-count").textContent=`(${t.size})`,t.size===0){this.playersPanel.innerHTML='<div class="empty-state">No players connected</div>',document.getElementById("dash-status").textContent="Waiting for players...",document.getElementById("dash-status").className="status-indicator status-waiting";return}document.getElementById("dash-status").textContent="Active",document.getElementById("dash-status").className="status-indicator status-active";let s="";t.forEach((i,n)=>{var d,p,h;const r=n===e?"vr":"pc",a=i.position||{x:0,y:0,z:0},c=i.state||"walking";s+=`
        <div class="player-item">
          <div>
            <span class="player-id">${n.substring(0,12)}</span>
            <span class="player-type ${r}">${r}</span>
          </div>
          <span class="player-pos">(${((d=a.x)==null?void 0:d.toFixed(2))||0}, ${((p=a.y)==null?void 0:p.toFixed(2))||0}, ${((h=a.z)==null?void 0:h.toFixed(2))||0})</span>
          <span class="player-state state-${c}">${c}</span>
        </div>
      `}),this.playersPanel.innerHTML=s}updateObjects(t){if(document.getElementById("object-count").textContent=`(${t.size})`,t.size===0){this.objectsPanel.innerHTML='<div class="empty-state">No objects</div>';return}let e="";t.forEach((s,i)=>{const n=s.heldBy,o=n?`held: ${n.substring(0,8)}`:"free";e+=`
        <div class="object-item">
          <span class="object-id">${i}</span>
          <span class="object-status ${n?"held":""}">${o}</span>
        </div>
      `}),this.objectsPanel.innerHTML=e}updatePhysicsStats(t){document.getElementById("stat-bodies").textContent=t.bodyCount||0,document.getElementById("stat-step-time").textContent=`${(t.stepTime||0).toFixed(2)}ms`,document.getElementById("stat-collisions").textContent=t.collisionCount||0,document.getElementById("stat-update-rate").textContent=`${t.updateRate||0} Hz`}updateNetworkStats(t){const e=t.vrClientId;document.getElementById("stat-vr-client").textContent=e?e.substring(0,12):"Not connected",document.getElementById("stat-vr-latency").textContent=t.vrLatency?`${t.vrLatency}ms`:"--",document.getElementById("stat-msg-rate").textContent=t.messageRate||0,document.getElementById("stat-bandwidth").textContent=`${(t.bandwidth||0).toFixed(1)} KB/s`}updateUptime(t){const e=Math.floor(t/60),s=t%60;document.getElementById("dash-uptime").textContent=`Uptime: ${e}:${s.toString().padStart(2,"0")}`}logEvent(t){this._addLogEntry(this.eventLog,t,"info")}logError(t){this._addLogEntry(this.errorLog,t,"error")}logWarning(t){this._addLogEntry(this.eventLog,t,"warn")}_addLogEntry(t,e,s){const i=t.querySelector(".empty-state");i&&i.remove();const n=new Date().toLocaleTimeString("en-US",{hour12:!1,hour:"2-digit",minute:"2-digit",second:"2-digit"}),o=document.createElement("div");for(o.className=`log-entry ${s}`,o.innerHTML=`
      <span class="log-time">${n}</span>
      <span class="log-msg">${e}</span>
    `,t.insertBefore(o,t.firstChild);t.children.length>this.maxLogEntries;)t.removeChild(t.lastChild)}hide(){this.container.style.display="none"}show(){this.container.style.display="block"}}class Ie{constructor(t,e,s,i){this.id=s,this.physicsWorld=t,this.scene=e,this.isHeld=!1,this.isRighting=!1,this.rightingProgress=0,this.stableTimer=0,this.startQuat=new bt,this.targetQuat=new bt;const n=U.player,o=(i.y||0)+n.height/2;if(e){const r=new zt(n.width,n.height,n.depth),a=new ft({color:65416});this.mesh=new vt(r,a),this.mesh.position.set(i.x,o,i.z),this.mesh.userData.grabbable=!0,this.mesh.userData.networkId=`block_${s}`,this.mesh.userData.isPlayer=!1,this.mesh.userData.isTestBlock=!0,e.add(this.mesh)}else this.mesh=null;this.body=this.createPhysicsBody(),t.addBody(`block_${s}`,this.body),this.body.position.set(i.x,o,i.z)}createPhysicsBody(){const t=U.player,e=new l(t.width/2,t.height/2,t.depth/2),s=new Ot(e),i=U.block,n=new S({mass:t.mass,type:S.DYNAMIC,material:this.physicsWorld.playerMaterial,linearDamping:t.linearDamping,angularDamping:i.angularDamping,fixedRotation:!1,collisionFilterGroup:this.physicsWorld.COLLISION_GROUPS.PLAYER,collisionFilterMask:this.physicsWorld.COLLISION_GROUPS.PLAYER|this.physicsWorld.COLLISION_GROUPS.VR_HAND|this.physicsWorld.COLLISION_GROUPS.ENVIRONMENT});return n.addShape(s),n}setHeld(t){this.isHeld=t,t?(this.body.type=S.KINEMATIC,this.body.velocity.set(0,0,0),this.body.angularVelocity.set(0,0,0)):(this.body.type=S.DYNAMIC,this.body.mass=U.player.mass,this.body.updateMassProperties(),this.body.wakeUp())}disableHandCollision(){this.body.collisionFilterMask=this.physicsWorld.COLLISION_GROUPS.PLAYER|this.physicsWorld.COLLISION_GROUPS.ENVIRONMENT}enableHandCollision(){this.body.collisionFilterMask=this.physicsWorld.COLLISION_GROUPS.PLAYER|this.physicsWorld.COLLISION_GROUPS.VR_HAND|this.physicsWorld.COLLISION_GROUPS.ENVIRONMENT}applyImpulse(t){this.body.type===S.DYNAMIC&&this.body.applyImpulse(new l(t.x,t.y,t.z),this.body.position)}setPosition(t,e,s){this.mesh&&this.mesh.position.set(t,e,s),this.body.position.set(t,e,s)}syncFromPhysics(){!this.isHeld&&this.mesh&&(this.mesh.position.set(this.body.position.x,this.body.position.y,this.body.position.z),this.mesh.quaternion.set(this.body.quaternion.x,this.body.quaternion.y,this.body.quaternion.z,this.body.quaternion.w))}syncToPhysics(){this.isHeld&&this.mesh&&(this.body.position.set(this.mesh.position.x,this.mesh.position.y,this.mesh.position.z),this.body.quaternion.set(this.mesh.quaternion.x,this.mesh.quaternion.y,this.mesh.quaternion.z,this.mesh.quaternion.w))}update(t){if(this.isHeld){this.stableTimer=0,this.isRighting=!1;return}const e=U.block,s=Math.sqrt(this.body.velocity.x**2+this.body.velocity.y**2+this.body.velocity.z**2);if(this.isRighting){if(s>e.stableThreshold*2){this.isRighting=!1,this.stableTimer=0,this.body.type=S.DYNAMIC,this.body.mass=U.player.mass,this.body.updateMassProperties(),this.body.wakeUp();return}if(this.rightingProgress+=t/e.rightingDuration,this.rightingProgress>=1)this.isRighting=!1,this.mesh&&this.mesh.quaternion.copy(this.targetQuat),this.body.quaternion.set(this.targetQuat.x,this.targetQuat.y,this.targetQuat.z,this.targetQuat.w),this.body.angularVelocity.set(0,0,0),this.body.type=S.DYNAMIC,this.body.mass=U.player.mass,this.body.updateMassProperties(),this.body.wakeUp();else if(this.mesh)this.mesh.quaternion.slerpQuaternions(this.startQuat,this.targetQuat,this.rightingProgress),this.syncToPhysics();else{const i=new bt;i.slerpQuaternions(this.startQuat,this.targetQuat,this.rightingProgress),this.body.quaternion.set(i.x,i.y,i.z,i.w)}}else if(s<e.stableThreshold){this.stableTimer+=t;const i=this.getTiltAngle();this.stableTimer>=e.stableTimeRequired&&i>e.tiltThreshold&&this.startRighting()}else this.stableTimer=0}getTiltAngle(){const t=this.mesh?this.mesh.quaternion:new bt(this.body.quaternion.x,this.body.quaternion.y,this.body.quaternion.z,this.body.quaternion.w),e=new V(0,1,0).applyQuaternion(t),s=new V(0,1,0),i=Math.max(-1,Math.min(1,e.dot(s)));return Math.acos(i)*(180/Math.PI)}startRighting(){this.isRighting=!0,this.rightingProgress=0,this.mesh?this.startQuat.copy(this.mesh.quaternion):this.startQuat.set(this.body.quaternion.x,this.body.quaternion.y,this.body.quaternion.z,this.body.quaternion.w);const t=new Jt().setFromQuaternion(this.startQuat,"YXZ");this.targetQuat.setFromEuler(new Jt(0,t.y,0,"YXZ")),this.body.type=S.KINEMATIC,this.body.velocity.set(0,0,0),this.body.angularVelocity.set(0,0,0)}dispose(){this.mesh&&this.scene&&(this.scene.remove(this.mesh),this.mesh.geometry.dispose(),this.mesh.material.dispose()),this.physicsWorld.removeBody(`block_${this.id}`)}}class Xn{constructor(t){this.lobbyUI=t,this.dashboardUI=null,this.testBlocks=[],this.lastUpdateTime=0,this.updateInterval=null,this.uptimeInterval=null,this.startTime=Date.now(),this.physicsStepTime=0,this.updateCount=0,this.lastStatsTime=Date.now(),this.messageCount=0,this.bytesReceived=0,this.vrClientId=null,this.lastVRHandTime=0,this.vrLatency=0}async start(){this.lobbyUI.hide(),this.dashboardUI=new Yn,this.dashboardUI.logEvent("Dashboard host starting...");try{await _.createRoom(),this.dashboardUI.logEvent("Room created, waiting for connections..."),W.initialize(),W.initializePhysics(),this.dashboardUI.logEvent("Physics system initialized"),W.collisionHandler.isBlockHeldByHand=(t,e)=>!1,this._setupNetworkHandlers(),this._registerDefaultObjects(),this.lastUpdateTime=performance.now(),this.updateInterval=setInterval(()=>this._update(),16),this.uptimeInterval=setInterval(()=>{const t=Math.floor((Date.now()-this.startTime)/1e3);this.dashboardUI.updateUptime(t)},1e3),setInterval(()=>this._updateStats(),1e3),this.dashboardUI.logEvent("Dashboard host ready")}catch(t){console.error("Failed to start dashboard host:",t),this.dashboardUI.logError(`Failed to start: ${t.message}`),this.lobbyUI.show(),this.lobbyUI.setStatus("Failed to start host: "+t.message)}}_setupNetworkHandlers(){_.on(L.VR_CLIENT_JOIN,t=>{if(this.vrClientId){this.dashboardUI.logWarning(`Rejected VR client ${t.playerId} - already have VR client`);return}this.vrClientId=t.senderId,_.setPlayerType(t.senderId,Je.VR),this.dashboardUI.logEvent(`VR client connected: ${t.senderId.substring(0,12)}`);const e=W.players.get(t.senderId);e&&(e.type="vr")}),_.on(L.VR_HAND_TRACKING,t=>{t.senderId===this.vrClientId&&(t.timestamp&&(this.vrLatency=Date.now()-t.timestamp),this.lastVRHandTime=Date.now(),W.updateVRHands(t.hands),this.messageCount++,this.bytesReceived+=150)}),_.on(L.VR_HEAD_TRACKING,t=>{t.senderId===this.vrClientId&&(W.updateVRHead(t.head),this.messageCount++,this.bytesReceived+=100)}),_.on(L.VR_GRAB_REQUEST,t=>{if(t.senderId!==this.vrClientId)return;const e=t.objectId,s=t.handIndex;if(e.startsWith("player_")){const i=e.replace("player_",""),n=W.pickupPlayer(i);_.sendTo(t.senderId,{type:L.GRAB_RESPONSE,objectId:e,granted:n,handIndex:s}),n&&this.dashboardUI.logEvent(`VR grabbed player: ${i.substring(0,8)}`)}else if(e.startsWith("block_")){const i=e.replace("block_",""),n=this.testBlocks.find(a=>a.id===i),o=W.objects.get(e),r=n&&o&&o.heldBy===null;r&&(o.heldBy="vr",n.setHeld(!0),this.dashboardUI.logEvent(`VR grabbed: ${e}`)),_.sendTo(t.senderId,{type:L.GRAB_RESPONSE,objectId:e,granted:r,handIndex:s})}else{const i=W.objects.get(e),n=i&&i.heldBy===null;n&&(i.heldBy="vr",this.dashboardUI.logEvent(`VR grabbed: ${e}`)),_.sendTo(t.senderId,{type:L.GRAB_RESPONSE,objectId:e,granted:n,handIndex:s})}}),_.on(L.OBJECT_UPDATE,t=>{if(t.senderId!==this.vrClientId)return;const e=t.objectId,s=t.position;if(e.startsWith("block_")){const i=e.replace("block_",""),n=this.testBlocks.find(o=>o.id===i);n&&n.isHeld&&s&&(n.body.position.set(s.x,s.y,s.z),t.rotation&&n.body.quaternion.set(t.rotation.x||0,t.rotation.y||0,t.rotation.z||0,t.rotation.w||1))}W.updateObjectPosition(e,s,t.rotation||{x:0,y:0,z:0})}),_.on(L.VR_RELEASE,t=>{if(t.senderId!==this.vrClientId)return;const e=t.objectId;if(e.startsWith("player_"))W.releasePlayer(t.velocity),this.dashboardUI.logEvent("VR released player");else if(e.startsWith("block_")){const s=e.replace("block_",""),i=this.testBlocks.find(o=>o.id===s),n=W.objects.get(e);i&&n&&n.heldBy==="vr"&&(n.heldBy=null,i.setHeld(!1),t.velocity&&i.body.velocity.set(t.velocity.x,t.velocity.y,t.velocity.z),t.angularVelocity&&i.body.angularVelocity.set(t.angularVelocity.x,t.angularVelocity.y,t.angularVelocity.z),i.disableHandCollision(),setTimeout(()=>i.enableHandCollision(),200),this.dashboardUI.logEvent(`VR released: ${e}`))}else{const s=W.objects.get(e);s&&s.heldBy==="vr"&&(s.heldBy=null,s.position=t.position,this.dashboardUI.logEvent(`VR released: ${e}`))}}),_.on(L.PLAYER_JOIN,t=>{const e=_.getPlayerType(t.playerId);this.dashboardUI.logEvent(`Player joined: ${t.playerId.substring(0,12)} (${e})`)}),_.on(L.PLAYER_LEAVE,t=>{this.dashboardUI.logEvent(`Player left: ${t.playerId.substring(0,12)}`),t.playerId===this.vrClientId&&(this.vrClientId=null,this.dashboardUI.logWarning("VR client disconnected"))})}_registerDefaultObjects(){W.registerObject("camera_main",{x:.5,y:.3,z:0},{x:0,y:0,z:0});const t=new Ie(W.physicsWorld,null,"test1",{x:.3,y:0,z:-.3}),e=new Ie(W.physicsWorld,null,"test2",{x:-.3,y:0,z:-.3});this.testBlocks=[t,e],W.registerObject("block_test1",{x:t.body.position.x,y:t.body.position.y,z:t.body.position.z},{x:0,y:0,z:0}),W.registerObject("block_test2",{x:e.body.position.x,y:e.body.position.y,z:e.body.position.z},{x:0,y:0,z:0}),this.dashboardUI.logEvent(`Created ${this.testBlocks.length} physics blocks`)}_update(){const t=performance.now(),e=(t-this.lastUpdateTime)/1e3;this.lastUpdateTime=t;const s=W.vrHandData,i=performance.now();W.updatePhysics(e,s),this.physicsStepTime=performance.now()-i,this.testBlocks.forEach(n=>{n.isHeld||n.update(e);const o=n.body.velocity,r=n.body.angularVelocity;(n.isHeld||Math.abs(o.x)>.01||Math.abs(o.y)>.01||Math.abs(o.z)>.01||Math.abs(r.x)>.1||Math.abs(r.y)>.1||Math.abs(r.z)>.1)&&W.updateObjectPosition(`block_${n.id}`,{x:n.body.position.x,y:n.body.position.y,z:n.body.position.z},{x:n.body.quaternion.x,y:n.body.quaternion.y,z:n.body.quaternion.z,w:n.body.quaternion.w})}),this.updateCount++}_updateStats(){var o,r;const t=Date.now(),e=(t-this.lastStatsTime)/1e3,s=Math.round(this.updateCount/e),i=Math.round(this.messageCount/e),n=this.bytesReceived/1024/e;this.dashboardUI.updatePhysicsStats({bodyCount:((r=(o=W.physicsWorld)==null?void 0:o.bodies)==null?void 0:r.size)||0,stepTime:this.physicsStepTime,collisionCount:0,updateRate:s}),this.dashboardUI.updateNetworkStats({vrClientId:this.vrClientId,vrLatency:this.vrLatency,messageRate:i,bandwidth:n}),this.dashboardUI.updatePlayers(W.players,this.vrClientId),this.dashboardUI.updateObjects(W.objects),this.updateCount=0,this.messageCount=0,this.bytesReceived=0,this.lastStatsTime=t}stop(){this.updateInterval&&(clearInterval(this.updateInterval),this.updateInterval=null),this.uptimeInterval&&(clearInterval(this.uptimeInterval),this.uptimeInterval=null),this.testBlocks.forEach(t=>t.dispose()),this.testBlocks=[],W.cleanup(),_.disconnect(),this.dashboardUI&&this.dashboardUI.hide()}}function Ye(){const w=new es;w.background=new ss(5263440);const t=new is(10,10),e=new ft({color:2236962,roughness:.8}),s=new vt(t,e);s.rotation.x=-Math.PI/2,s.receiveShadow=!0,w.add(s);const i=[],n=new ns(4210752,2);w.add(n);const o=new os(16777215,2);return o.position.set(1,4,2),o.castShadow=!0,w.add(o),{scene:w,grabbables:i}}function Xe(w=!0){const t=new Qe({antialias:!0});return t.setPixelRatio(window.devicePixelRatio),t.setSize(window.innerWidth,window.innerHeight),t.shadowMap.enabled=!0,w&&(t.xr.enabled=!0),document.body.appendChild(t.domElement),t}function Ke(){const w=new ts(50,window.innerWidth/window.innerHeight,.1,100);return w.position.set(0,1.6,2),w}const Re=new cs,Ce=new V;class Se{constructor(t,e,s,i,n){this.controller=e,this.handModel=t,this.envMap=null;let o;!n||!n.primitive||n.primitive==="sphere"?o=new rs(1,10,10):n.primitive==="box"&&(o=new zt(1,1,1));const r=new ft;this.handMesh=new as(o,r,30),this.handMesh.frustumCulled=!1,this.handMesh.instanceMatrix.setUsage(ls),this.handMesh.castShadow=!0,this.handMesh.receiveShadow=!0,this.handModel.add(this.handMesh),this.joints=["wrist","thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip","index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip","middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip","ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip","pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"]}updateMesh(){const e=this.controller.joints;let s=0;for(let i=0;i<this.joints.length;i++){const n=e[this.joints[i]];n.visible&&(Ce.setScalar(n.jointRadius||.008),Re.compose(n.position,n.quaternion,Ce),this.handMesh.setMatrixAt(i,Re),s++)}this.handMesh.count=s,this.handMesh.instanceMatrix.needsUpdate=!0}}const Kn="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/";class Zn{constructor(t,e,s,i,n=null,o=null){this.controller=e,this.handModel=t,this.bones=[],n===null&&(n=new hs,n.setPath(s||Kn)),n.load(`${i}.glb`,r=>{const a=r.scene.children[0];this.handModel.add(a);const c=a.getObjectByProperty("type","SkinnedMesh");c.frustumCulled=!1,c.castShadow=!0,c.receiveShadow=!0,["wrist","thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip","index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip","middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip","ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip","pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"].forEach(p=>{const h=a.getObjectByName(p);h!==void 0?h.jointName=p:console.warn(`Couldn't find ${p} in ${i} hand mesh`),this.bones.push(h)}),o&&o(a)})}updateMesh(){const t=this.controller.joints;for(let e=0;e<this.bones.length;e++){const s=this.bones[e];if(s){const i=t[s.jointName];if(i.visible){const n=i.position;s.position.copy(n),s.quaternion.copy(i.quaternion)}}}}}class Jn extends ds{constructor(t){super(),this.controller=t,this.motionController=null,this.envMap=null,this.mesh=null}updateMatrixWorld(t){super.updateMatrixWorld(t),this.motionController&&this.motionController.updateMesh()}}class Qn{constructor(t=null,e=null){this.gltfLoader=t,this.path=null,this.onLoad=e}setPath(t){return this.path=t,this}createHandModel(t,e){const s=new Jn(t);return t.addEventListener("connected",i=>{const n=i.data;n.hand&&!s.motionController&&(s.xrInputSource=n,e===void 0||e==="spheres"?s.motionController=new Se(s,t,this.path,n.handedness,{primitive:"sphere"}):e==="boxes"?s.motionController=new Se(s,t,this.path,n.handedness,{primitive:"box"}):e==="mesh"&&(s.motionController=new Zn(s,t,this.path,n.handedness,this.gltfLoader,this.onLoad))),t.visible=!0}),t.addEventListener("disconnected",()=>{t.visible=!1}),s}}function to(w,t){const e=new Qn,s=[];for(let i=0;i<2;i++){const n=w.xr.getHand(i);t.add(n);const o=e.createHandModel(n,"mesh");n.add(o),s.push(n)}return s}const ze="thumb-tip",Me="index-finger-tip",eo=["wrist","thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip","index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip","middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip","ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip","pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"],so=["thumb-tip","index-finger-tip","middle-finger-tip","ring-finger-tip","pinky-finger-tip"],io=.02,no=.025;class Be{constructor(t,e){this.hand=t,this.handedness=e,this.isPinching=!1,this.pinchStarted=!1,this.pinchEnded=!1,this.pinchPosition=new V,this._thumbPos=new V,this._indexPos=new V}update(){this.pinchStarted=!1,this.pinchEnded=!1;const t=this.hand.joints[ze],e=this.hand.joints[Me];if(!t||!e)return;t.getWorldPosition(this._thumbPos),e.getWorldPosition(this._indexPos);const s=this._thumbPos.distanceTo(this._indexPos);this.pinchPosition.lerpVectors(this._thumbPos,this._indexPos,.5);const i=this.isPinching;s<io?this.isPinching=!0:s>no&&(this.isPinching=!1),this.isPinching&&!i&&(this.pinchStarted=!0),!this.isPinching&&i&&(this.pinchEnded=!0)}getPinchPosition(){return this.pinchPosition}getPinchOrientation(){const t=this.hand.joints.wrist;return t?t.quaternion.clone():new bt}getJointData(){const t=[],e=new V;for(const s of eo){const i=this.hand.joints[s];i?(i.getWorldPosition(e),t.push({x:e.x,y:e.y,z:e.z})):t.push(null)}return{joints:t,pinching:this.isPinching}}getEssentialJointData(){const t=[],e=new V;for(const s of so){const i=this.hand.joints[s];i?(i.getWorldPosition(e),t.push({x:e.x,y:e.y,z:e.z})):t.push(null)}return{joints:t,pinching:this.isPinching}}hasValidData(){return this.hand.joints&&this.hand.joints[ze]&&this.hand.joints[Me]}}const oo=.1;class ro{constructor(t){this.grabbableObjects=t,this.grabbedObjects=new Map,this.grabOffsets=new Map,this.grabRotationOffsets=new Map,this.positionHistories=new Map,this.rotationHistories=new Map,this._maxPositionHistory=10,this._maxRotationHistory=10,this.onGrab=null,this.onRelease=null}update(t){var s,i;for(let n=0;n<t.length;n++){const o=t[n];if(o.update(),o.pinchStarted&&!this.grabbedObjects.has(n)){const r=o.getPinchPosition();let a=null,c=oo;for(const d of this.grabbableObjects){if(!d.userData.grabbable||this.isObjectHeld(d))continue;const p=r.distanceTo(d.position);p<c&&(a=d,c=p)}if(a){this.grabbedObjects.set(n,a),this.positionHistories.set(n,[]),this.rotationHistories.set(n,[]);const d=o.getPinchOrientation(),p=new V().subVectors(a.position,r);p.applyQuaternion(d.clone().invert()),this.grabOffsets.set(n,p);const h=new bt().copy(d).invert().multiply(a.quaternion);this.grabRotationOffsets.set(n,h),(s=a.material)!=null&&s.emissive&&a.material.emissive.setHex(2236962),this.onGrab&&a.userData.networkId&&this.onGrab(a.userData.networkId,a,n)}}if(o.pinchEnded&&this.grabbedObjects.has(n)){const r=this.grabbedObjects.get(n);(i=r.material)!=null&&i.emissive&&r.material.emissive.setHex(0),this.onRelease&&r.userData.networkId&&this.onRelease(r.userData.networkId,{x:r.position.x,y:r.position.y,z:r.position.z},r,n),this.grabbedObjects.delete(n),this.grabOffsets.delete(n),this.grabRotationOffsets.delete(n),this.positionHistories.delete(n),this.rotationHistories.delete(n)}}const e=performance.now()/1e3;for(const[n,o]of this.grabbedObjects){const r=t[n];if(!r)continue;const a=r.getPinchPosition(),c=r.getPinchOrientation(),d=this.grabOffsets.get(n),p=this.grabRotationOffsets.get(n);if(!d||!p)continue;const h=d.clone().applyQuaternion(c);o.position.copy(a).add(h),o.quaternion.copy(c).multiply(p);const u=this.positionHistories.get(n)||[];u.push({pos:o.position.clone(),time:e}),u.length>this._maxPositionHistory&&u.shift(),this.positionHistories.set(n,u);const y=this.rotationHistories.get(n)||[];y.push({quat:o.quaternion.clone(),time:e}),y.length>this._maxRotationHistory&&y.shift(),this.rotationHistories.set(n,y)}}isObjectHeld(t){for(const e of this.grabbedObjects.values())if(e===t)return!0;return!1}isObjectHeldByHand(t,e){const s=this.grabbedObjects.get(e);return s?typeof t=="string"?s.userData.networkId===t:s===t:!1}getHoldingHand(t){for(const[e,s]of this.grabbedObjects)if(s===t)return e;return-1}getGrabbedObjectId(t){if(t===void 0){for(const s of this.grabbedObjects.values())return s.userData.networkId||null;return null}const e=this.grabbedObjects.get(t);return(e==null?void 0:e.userData.networkId)||null}getGrabbedObjectPosition(t){if(t===void 0){for(const s of this.grabbedObjects.values())return{x:s.position.x,y:s.position.y,z:s.position.z};return null}const e=this.grabbedObjects.get(t);return e?{x:e.position.x,y:e.position.y,z:e.position.z}:null}getGrabbingHandIndices(){return Array.from(this.grabbedObjects.keys())}getObjectVelocity(t){const e=this.positionHistories.get(t);if(!e||e.length<2)return new V;const s=new V;let i=0;for(let n=1;n<e.length;n++){const o=e[n-1],r=e[n],a=r.time-o.time;a>0&&(s.add(new V().subVectors(r.pos,o.pos).divideScalar(a)),i++)}return i>0&&s.divideScalar(i),s}confirmGrab(t,e){const s=this.grabbedObjects.get(e);s&&s.userData.networkId===t&&console.log(`Grab confirmed: ${t} by hand ${e}`)}cancelGrab(t,e){var i;const s=this.grabbedObjects.get(e);s&&s.userData.networkId===t&&((i=s.material)!=null&&i.emissive&&s.material.emissive.setHex(0),this.grabbedObjects.delete(e),this.grabOffsets.delete(e),this.grabRotationOffsets.delete(e),this.positionHistories.delete(e),this.rotationHistories.delete(e),console.log(`Grab denied: ${t} by hand ${e}`))}isObjectHeldById(t){for(const e of this.grabbedObjects.values())if(e.userData.networkId===t)return!0;return!1}getObjectAngularVelocity(t){const e=this.rotationHistories.get(t);if(!e||e.length<2)return new V;const s=e[e.length-2],i=e[e.length-1],n=i.time-s.time;if(n<=0)return new V;const o=new bt().copy(i.quat).multiply(new bt().copy(s.quat).invert()),r=new V(2*o.x/n,2*o.y/n,2*o.z/n);return o.w<0&&r.negate(),r}}class ao{constructor(t,e,s){this.camera=t,this.grabbableObjects=e,this.scene=s,this.grabbedObject=null,this.grabDistance=0,this._grabOffset=new V,this.raycaster=new ps,this.mouse=new ie,this.onGrabRequest=null,this.onRelease=null,this.pendingGrab=null,this.setupControls()}setupControls(){document.addEventListener("mousedown",t=>this.onMouseDown(t)),document.addEventListener("mouseup",t=>this.onMouseUp(t))}onMouseDown(t){if(t.button!==0||this.grabbedObject)return;this.raycaster.setFromCamera(new ie(0,0),this.camera);const e=this.raycaster.intersectObjects(this.grabbableObjects);if(e.length>0){const s=e[0];s.object.userData.grabbable&&s.object.userData.networkId&&(this.pendingGrab=s.object,this.grabDistance=s.distance,this.onGrabRequest&&this.onGrabRequest(s.object.userData.networkId))}}onMouseUp(t){if(t.button===0){if(this.grabbedObject){const e=this.grabbedObject;e.material.emissive&&e.material.emissive.setHex(0),this.onRelease&&e.userData.networkId&&this.onRelease(e.userData.networkId,{x:e.position.x,y:e.position.y,z:e.position.z}),this.grabbedObject=null}this.pendingGrab=null}}onGrabGranted(t){this.pendingGrab&&this.pendingGrab.userData.networkId===t&&(this.grabbedObject=this.pendingGrab,this.grabbedObject.material.emissive&&this.grabbedObject.material.emissive.setHex(2236962)),this.pendingGrab=null}onGrabDenied(t){this.pendingGrab=null}update(){if(this.grabbedObject){const t=new V(0,0,-1);t.applyQuaternion(this.camera.quaternion),this.grabbedObject.position.copy(this.camera.position).add(t.multiplyScalar(this.grabDistance))}}getGrabbedObjectId(){var t;return((t=this.grabbedObject)==null?void 0:t.userData.networkId)||null}getGrabbedObjectPosition(){return this.grabbedObject?{x:this.grabbedObject.position.x,y:this.grabbedObject.position.y,z:this.grabbedObject.position.z}:null}}class lo{constructor(){this.players=new Map,this.objects=new Map,this.localHandData=null,this.localHeadData=null,this.onPlayersUpdated=null,this.onObjectsUpdated=null,this.onGrabResponse=null,this.onPlayerPhysicsUpdated=null,this.onRagdollTriggered=null,this.onRagdollRecovery=null,this.handUpdateInterval=null,this.headUpdateInterval=null,this.lastSentHandData=null,this.movementThreshold=.002,this.forceUpdateCounter=0,this.forceUpdateInterval=10}initialize(){_.on("initial_state",t=>this.onInitialState(t)),_.on(L.WORLD_STATE,t=>this.onWorldState(t)),_.on(L.GRAB_RESPONSE,t=>this.handleGrabResponse(t)),_.on(L.RAGDOLL_TRIGGERED,t=>this.handleRagdollTriggered(t)),_.on(L.RAGDOLL_RECOVERY,t=>this.handleRagdollRecovery(t)),_.on("disconnected",()=>this.onDisconnected()),this.handUpdateInterval=setInterval(()=>this.sendHandTracking(),33),this.headUpdateInterval=setInterval(()=>this.sendHeadTracking(),33)}onInitialState(t){console.log("VR Client received initial state"),t.players.forEach(e=>this.players.set(e.id,e)),t.objects.forEach(e=>this.objects.set(e.id,e)),this.onPlayersUpdated&&this.onPlayersUpdated(this.players),this.onObjectsUpdated&&this.onObjectsUpdated(this.objects)}onWorldState(t){var e,s;t.isFullState?(this.players.clear(),t.players.forEach(i=>{this.players.set(i.id,i)}),this.objects.clear(),t.objects.forEach(i=>this.objects.set(i.id,i))):((e=t.players)==null||e.forEach(i=>{this.players.set(i.id,i)}),(s=t.objects)==null||s.forEach(i=>this.objects.set(i.id,i))),this.onPlayersUpdated&&this.onPlayersUpdated(this.players),this.onObjectsUpdated&&this.onObjectsUpdated(this.objects),t.playerPhysics&&this.onPlayerPhysicsUpdated&&this.onPlayerPhysicsUpdated(t.playerPhysics)}handleGrabResponse(t){this.onGrabResponse&&this.onGrabResponse(t.objectId,t.granted,t.handIndex)}handleRagdollTriggered(t){this.onRagdollTriggered&&this.onRagdollTriggered(t)}handleRagdollRecovery(t){this.onRagdollRecovery&&this.onRagdollRecovery(t)}onDisconnected(){console.log("VR Client disconnected from host"),this.cleanup()}setHandData(t){this.localHandData=t}setHeadData(t){this.localHeadData=t}_hasHandMoved(t,e){var o,r,a,c;if(!e||!t)return!0;const s=(d,p)=>{if(!d||!p||!d.joints||!p.joints)return!0;const h=d.joints[0],u=p.joints[0];if(!h||!u)return!0;const y=Math.abs(h.x-u.x),m=Math.abs(h.y-u.y),g=Math.abs(h.z-u.z);return y>this.movementThreshold||m>this.movementThreshold||g>this.movementThreshold},i=s(t.left,e.left)||((o=t.left)==null?void 0:o.pinching)!==((r=e.left)==null?void 0:r.pinching),n=s(t.right,e.right)||((a=t.right)==null?void 0:a.pinching)!==((c=e.right)==null?void 0:c.pinching);return i||n}sendHandTracking(){if(!this.localHandData)return;this.forceUpdateCounter++;const t=this.forceUpdateCounter>=this.forceUpdateInterval;t&&(this.forceUpdateCounter=0),(t||this._hasHandMoved(this.localHandData,this.lastSentHandData))&&(_.sendToHost({type:L.VR_HAND_TRACKING,hands:this.localHandData,timestamp:Date.now()}),this.lastSentHandData=JSON.parse(JSON.stringify(this.localHandData)))}sendHeadTracking(){this.localHeadData&&_.sendToHost({type:L.VR_HEAD_TRACKING,head:this.localHeadData,timestamp:Date.now()})}requestGrab(t,e){_.sendToHost({type:L.VR_GRAB_REQUEST,objectId:t,handIndex:e})}releaseObject(t,e,s,i,n){_.sendToHost({type:L.VR_RELEASE,objectId:t,position:e,velocity:s,angularVelocity:i,handIndex:n})}sendObjectUpdate(t,e,s){_.sendToHost({type:L.OBJECT_UPDATE,objectId:t,position:e,rotation:s})}getPlayers(){return this.players}getObjects(){return this.objects}cleanup(){this.handUpdateInterval&&(clearInterval(this.handUpdateInterval),this.handUpdateInterval=null),this.headUpdateInterval&&(clearInterval(this.headUpdateInterval),this.headUpdateInterval=null)}}const nt=new lo;function co(w){var e,s,i,n;if(!w||!Array.isArray(w))return null;const t={};return(s=(e=w[0])==null?void 0:e.hasValidData)!=null&&s.call(e)&&(t.left=w[0].getEssentialJointData()),(n=(i=w[1])==null?void 0:i.hasValidData)!=null&&n.call(i)&&(t.right=w[1].getEssentialJointData()),Object.keys(t).length>0?t:null}function ho(w){return w?{position:{x:w.position.x,y:w.position.y,z:w.position.z},rotation:{x:w.rotation.x,y:w.rotation.y,z:w.rotation.z}}:null}class po{constructor(){this.reset()}reset(){this.mode=null,this.isInGame=!1,this.renderer=null,this.camera=null,this.scene=null,this.clock=null,this.grabbables=[],this.testBlocks=[],this.remotePlayers=new Map,this.placeableCamera=null,this.handTrackers=[],this.grabSystem=null,this.grabHandler=null,this.localPlayer=null,this.pcGrabSystem=null,this.vrHostAvatar=null,this.lobbyUI=null,this.gameHUD=null}isHost(){return this.mode==="host"}isClient(){return this.mode==="client"}setMode(t){this.mode=t,this.isInGame=t!==null}disposeRemotePlayers(){this.remotePlayers.forEach(t=>{t.dispose&&t.dispose()}),this.remotePlayers.clear()}disposeTestBlocks(){this.testBlocks.forEach(t=>{t.dispose&&t.dispose()}),this.testBlocks=[]}dispose(){var t,e,s;this.disposeRemotePlayers(),this.disposeTestBlocks(),(t=this.placeableCamera)!=null&&t.dispose&&this.placeableCamera.dispose(),(e=this.localPlayer)!=null&&e.dispose&&this.localPlayer.dispose(),(s=this.vrHostAvatar)!=null&&s.dispose&&this.vrHostAvatar.dispose(),this.renderer&&this.renderer.dispose(),this.reset()}}const v=new po;class uo{constructor(t){this.lobbyUI=t}async start(){this.lobbyUI.hide(),v.setMode("vr-client"),v.renderer=Xe(!0),v.camera=Ke();const t=Ye();v.scene=t.scene,v.grabbables=t.grabbables,v.clock=new Oe,this._createBlockMeshes(),this._createCameraMesh();const e=to(v.renderer,v.scene);v.handTrackers=[new Be(e[0],"left"),new Be(e[1],"right")],v.grabSystem=new ro(v.grabbables),nt.initialize(),this._setupNetworkCallbacks(),this._setupGrabCallbacks(),v.gameHUD=this.lobbyUI.createGameHUD("VR Client",!0),this._setupVRButton(),this._setupResizeHandler(),v.renderer.setAnimationLoop(()=>this.update())}_setupNetworkCallbacks(){nt.onPlayersUpdated=t=>{this._updateRemotePlayers(t)},nt.onObjectsUpdated=t=>{this._updateObjectsFromNetwork(t)},nt.onGrabResponse=(t,e,s)=>{e?v.grabSystem.confirmGrab(t,s):v.grabSystem.cancelGrab(t,s)},nt.onPlayerPhysicsUpdated=t=>{t.forEach(e=>{const s=v.remotePlayers.get(e.id);s&&s.updatePhysicsState(e)})},nt.onRagdollTriggered=t=>{const e=v.remotePlayers.get(t.playerId);e&&e.startRagdoll(t.impulse)},nt.onRagdollRecovery=t=>{const e=v.remotePlayers.get(t.playerId);e&&e.setRecovering()}}_setupGrabCallbacks(){v.grabSystem.onGrab=(t,e,s)=>{nt.requestGrab(t,s)},v.grabSystem.onRelease=(t,e,s,i)=>{const n=v.grabSystem.getObjectVelocity(i),o=v.grabSystem.getObjectAngularVelocity(i);nt.releaseObject(t,{x:e.x,y:e.y,z:e.z},n?{x:n.x,y:n.y,z:n.z}:null,o?{x:o.x,y:o.y,z:o.z}:null,i)}}_setupVRButton(){const t=document.createElement("button");t.textContent="Enter VR",t.style.cssText="position:fixed;bottom:20px;left:50%;transform:translateX(-50%);padding:15px 30px;font-size:18px;z-index:1000;",document.body.appendChild(t),t.onclick=async()=>{try{const e=await navigator.xr.requestSession("immersive-vr",{requiredFeatures:["hand-tracking"],optionalFeatures:["local-floor","bounded-floor"]});v.renderer.xr.setSession(e),t.style.display="none"}catch(e){console.error("Failed to start VR:",e);try{const s=await navigator.xr.requestSession("immersive-vr",{optionalFeatures:["local-floor","hand-tracking"]});v.renderer.xr.setSession(s),t.style.display="none"}catch(s){alert("Could not start VR: "+s.message)}}}}_setupResizeHandler(){window.addEventListener("resize",()=>{!v.camera||!v.renderer||(v.camera.aspect=window.innerWidth/window.innerHeight,v.camera.updateProjectionMatrix(),v.renderer.setSize(window.innerWidth,window.innerHeight))})}update(){const t=v.clock.getDelta();v.grabSystem.update(v.handTrackers);const e=co(v.handTrackers);e&&nt.setHandData(e);const s=v.renderer.xr.getCamera(),i=ho(s);i&&nt.setHeadData(i),this._updateGrabbedObjects(),v.remotePlayers.forEach(n=>{n.update(t)}),v.renderer.render(v.scene,v.camera)}_updateGrabbedObjects(){const t=v.grabSystem.getGrabbingHandIndices();for(const e of t){const s=v.grabSystem.getGrabbedObjectId(e);if(!s)continue;const i=v.grabSystem.getGrabbedObjectPosition(e);if(i&&(nt.sendObjectUpdate(s,i,null),s.startsWith("player_"))){const n=s.replace("player_",""),o=v.remotePlayers.get(n);o&&o.setPosition(i.x,i.y,i.z)}}}_updateRemotePlayers(t){t.forEach((e,s)=>{if(!v.remotePlayers.has(s)){const i=new Ne(s,v.scene);v.remotePlayers.set(s,i),v.grabbables.push(i.mesh)}v.remotePlayers.get(s).updateFromState(e)}),v.remotePlayers.forEach((e,s)=>{if(!t.has(s)){const i=v.grabbables.indexOf(e.mesh);i>-1&&v.grabbables.splice(i,1),e.dispose(),v.remotePlayers.delete(s)}})}_updateObjectsFromNetwork(t){t.forEach((e,s)=>{var o;if((o=v.grabSystem)==null?void 0:o.isObjectHeldById(s))return;const n=v.grabbables.find(r=>r.userData.networkId===s);n&&e.position&&n.position.set(e.position.x,e.position.y,e.position.z)})}_createBlockMeshes(){[{id:"block_test1",pos:new V(.3,0,-.3)},{id:"block_test2",pos:new V(-.3,0,-.3)}].forEach(({id:e,pos:s})=>{const i=new zt(.08,.08,.08),n=new ft({color:16737792,roughness:.5,metalness:.3}),o=new vt(i,n);o.position.copy(s),o.userData.networkId=e,o.userData.grabbable=!0,o.castShadow=!0,o.receiveShadow=!0,v.scene.add(o),v.grabbables.push(o)})}_createCameraMesh(){const t=new Le,e=new zt(.08,.06,.1),s=new ft({color:3355443,roughness:.3,metalness:.7}),i=new vt(e,s);t.add(i);const n=new He(.025,.03,.04,16),o=new ft({color:1118481,roughness:.2,metalness:.8}),r=new vt(n,o);r.rotation.x=Math.PI/2,r.position.z=-.07,t.add(r),t.position.set(.5,.3,0),t.userData.networkId="camera_main",t.userData.grabbable=!0,v.scene.add(t),v.grabbables.push(t)}}class yo{constructor(){this.players=new Map,this.objects=new Map,this.vrHandData=null,this.vrHeadData=null,this.onPlayersUpdated=null,this.onObjectsUpdated=null,this.onVRHandsUpdated=null,this.onGrabResponse=null,this.onPickedUp=null,this.onReleased=null,this.onPositionUpdate=null,this.onPlayerPhysicsUpdated=null,this.onRagdollTriggered=null,this.onRagdollRecovery=null,this.onLocalRagdollUpdate=null,this.onLocalRecovery=null,this.onLocalWalking=null,this.stateUpdateInterval=null,this.localPlayerState=null,this.isBeingHeld=!1}initialize(){_.on("initial_state",t=>this.onInitialState(t)),_.on(L.WORLD_STATE,t=>this.onWorldState(t)),_.on(L.GRAB_RESPONSE,t=>this.handleGrabResponse(t)),_.on(L.PLAYER_PICKUP,t=>this.handlePickedUp(t)),_.on(L.PLAYER_RELEASE,t=>this.handleReleased(t)),_.on(L.PLAYER_POSITION,t=>this.handlePositionUpdate(t)),_.on(L.RAGDOLL_TRIGGERED,t=>this.handleRagdollTriggered(t)),_.on(L.RAGDOLL_RECOVERY,t=>this.handleRagdollRecovery(t)),_.on("disconnected",()=>this.onDisconnected()),this.stateUpdateInterval=setInterval(()=>this.sendPlayerState(),50)}onInitialState(t){console.log("Received initial state"),t.players.forEach(e=>this.players.set(e.id,e)),t.objects.forEach(e=>this.objects.set(e.id,e)),this.onPlayersUpdated&&this.onPlayersUpdated(this.players),this.onObjectsUpdated&&this.onObjectsUpdated(this.objects)}onWorldState(t){var e,s;if(t.isFullState?(this.players.clear(),t.players.forEach(i=>{i.id!==_.playerId&&this.players.set(i.id,i)}),this.objects.clear(),t.objects.forEach(i=>this.objects.set(i.id,i))):((e=t.players)==null||e.forEach(i=>{i.id!==_.playerId&&this.players.set(i.id,i)}),(s=t.objects)==null||s.forEach(i=>this.objects.set(i.id,i))),this.vrHeadData=t.vrHead,t.vrHands&&(this.vrHandData=t.vrHands,this.onVRHandsUpdated&&this.onVRHandsUpdated(t.vrHands)),this.onPlayersUpdated&&this.onPlayersUpdated(this.players),this.onObjectsUpdated&&this.onObjectsUpdated(this.objects),t.playerPhysics){const i=t.playerPhysics.find(n=>n.id===_.playerId);i&&(i.state==="ragdoll"||i.state==="recovering"?this.onLocalRagdollUpdate&&this.onLocalRagdollUpdate(i):i.state==="walking"&&this.onLocalWalking&&this.onLocalWalking()),this.onPlayerPhysicsUpdated&&this.onPlayerPhysicsUpdated(t.playerPhysics)}}handleGrabResponse(t){this.onGrabResponse&&this.onGrabResponse(t.objectId,t.granted)}handlePickedUp(t){console.log("Being picked up by VR player!"),this.isBeingHeld=!0,this.onPickedUp&&this.onPickedUp()}handleReleased(t){console.log("Released by VR player!"),this.isBeingHeld=!1,this.onReleased&&this.onReleased((t==null?void 0:t.throwVelocity)||null)}handlePositionUpdate(t){this.onPositionUpdate&&t.position&&this.onPositionUpdate(t.position)}handleRagdollTriggered(t){console.log("Player ragdoll triggered:",t.playerId),t.playerId===_.playerId&&this.onLocalRagdollUpdate&&this.onLocalRagdollUpdate({state:"ragdoll",position:null,impulse:t.impulse}),this.onRagdollTriggered&&this.onRagdollTriggered(t)}handleRagdollRecovery(t){console.log("Player ragdoll recovery:",t.playerId),t.playerId===_.playerId&&this.onLocalRecovery&&this.onLocalRecovery(),this.onRagdollRecovery&&this.onRagdollRecovery(t)}onDisconnected(){console.log("Disconnected from host"),this.cleanup()}setLocalPlayerState(t){this.localPlayerState=t}sendPlayerState(){this.localPlayerState&&_.sendToHost({type:L.PLAYER_STATE,position:this.localPlayerState.position,rotation:this.localPlayerState.rotation})}requestGrab(t){_.sendToHost({type:L.GRAB_REQUEST,objectId:t})}releaseObject(t,e,s){_.sendToHost({type:L.OBJECT_RELEASE,objectId:t,position:e,rotation:s})}sendObjectUpdate(t,e){_.sendToHost({type:L.OBJECT_UPDATE,objectId:t,position:e})}getPlayers(){return this.players}getObjects(){return this.objects}getVRHandData(){return this.vrHandData}getVRHeadData(){return this.vrHeadData}cleanup(){this.stateUpdateInterval&&clearInterval(this.stateUpdateInterval)}}const Z=new yo,Vt=.08,fo=.5;class mo{constructor(t,e){this.camera=t,this.scene=e,this.velocity=new V,this.moveSpeed=fo,this.keys={w:!1,a:!1,s:!1,d:!1},this.euler=new Jt(0,0,0,"YXZ"),this.isPointerLocked=!1,this.isBeingHeld=!1,this.currentState=st.WALKING,this.setupControls()}setupControls(){document.addEventListener("keydown",t=>this.onKeyDown(t)),document.addEventListener("keyup",t=>this.onKeyUp(t)),document.addEventListener("mousemove",t=>this.onMouseMove(t)),document.addEventListener("pointerlockchange",()=>{this.isPointerLocked=document.pointerLockElement!==null})}requestPointerLock(){document.body.requestPointerLock()}onKeyDown(t){switch(t.code){case"KeyW":this.keys.w=!0;break;case"KeyA":this.keys.a=!0;break;case"KeyS":this.keys.s=!0;break;case"KeyD":this.keys.d=!0;break}}onKeyUp(t){switch(t.code){case"KeyW":this.keys.w=!1;break;case"KeyA":this.keys.a=!1;break;case"KeyS":this.keys.s=!1;break;case"KeyD":this.keys.d=!1;break}}onMouseMove(t){if(!this.isPointerLocked)return;const e=.002;this.euler.setFromQuaternion(this.camera.quaternion),this.euler.y-=t.movementX*e,this.euler.x-=t.movementY*e,this.euler.x=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.euler.x)),this.camera.quaternion.setFromEuler(this.euler)}update(t){if(this.isBeingHeld||this.currentState===st.RAGDOLL||this.currentState===st.RECOVERING)return;const e=new V;this.camera.getWorldDirection(e),e.y=0,e.normalize();const s=new V;s.crossVectors(e,new V(0,1,0)).normalize(),this.keys.w&&this.camera.position.addScaledVector(e,this.moveSpeed*t),this.keys.s&&this.camera.position.addScaledVector(e,-this.moveSpeed*t),this.keys.a&&this.camera.position.addScaledVector(s,-this.moveSpeed*t),this.keys.d&&this.camera.position.addScaledVector(s,this.moveSpeed*t),this.camera.position.y=Vt}isCurrentlyMoving(){return this.keys.w||this.keys.a||this.keys.s||this.keys.d}getState(){return{position:{x:this.camera.position.x,y:this.camera.position.y,z:this.camera.position.z},rotation:this.euler.y,isMoving:this.isCurrentlyMoving()}}setPosition(t,e,s){this.camera.position.set(t,e,s)}setBeingHeld(t,e){this.isBeingHeld=t,t&&(this.currentState=st.HELD,e&&this.camera.position.set(e.x,e.y,e.z))}updateFromPhysics(t){t&&this.camera.position.set(t.position.x,t.position.y+Vt,t.position.z)}setRagdollState(t){this.currentState=st.RAGDOLL,this.isBeingHeld=!1,this.updateFromPhysics(t)}setRecovering(){this.currentState=st.RECOVERING,this.camera.position.y=Vt}setWalking(){this.currentState=st.WALKING,this.camera.position.y=Vt}getCurrentState(){return this.currentState}}class go{constructor(t){this.lobbyUI=t}start(){this.lobbyUI.hide(),v.setMode("client"),v.renderer=Xe(!1),v.camera=Ke();const t=Ye();v.scene=t.scene,v.grabbables=t.grabbables,v.clock=new Oe,this._createBlockMeshes(),this._createCameraMesh(),v.localPlayer=new mo(v.camera,v.scene),v.localPlayer.setPosition(0,.08,.5),v.pcGrabSystem=new ao(v.camera,v.grabbables,v.scene),this._setupGrabCallbacks(),v.vrHostAvatar=new us(v.scene),Z.initialize(),this._setupNetworkCallbacks(),v.gameHUD=this.lobbyUI.createGameHUD(_.roomCode,!1),this._setupInstructions(),this._setupResizeHandler(),this._animate()}_setupGrabCallbacks(){v.pcGrabSystem.onGrabRequest=t=>{Z.requestGrab(t)},v.pcGrabSystem.onRelease=(t,e)=>{Z.releaseObject(t,e,{x:0,y:0,z:0})}}_setupNetworkCallbacks(){Z.onPlayersUpdated=t=>{this._updateRemotePlayers(t)},Z.onObjectsUpdated=t=>{this._updateObjectsFromNetwork(t)},Z.onVRHandsUpdated=t=>{v.vrHostAvatar&&v.vrHostAvatar.updateHands(t)},Z.onGrabResponse=(t,e)=>{e?v.pcGrabSystem.onGrabGranted(t):v.pcGrabSystem.onGrabDenied(t)},Z.onPickedUp=()=>{v.localPlayer.setBeingHeld(!0)},Z.onReleased=t=>{v.localPlayer.setBeingHeld(!1)},Z.onPositionUpdate=t=>{v.localPlayer.setPosition(t.x,t.y,t.z)},Z.onPlayerPhysicsUpdated=t=>{t.forEach(e=>{const s=v.remotePlayers.get(e.id);s&&s.updatePhysicsState(e)})},Z.onRagdollTriggered=t=>{const e=v.remotePlayers.get(t.playerId);e&&e.startRagdoll(t.impulse)},Z.onRagdollRecovery=t=>{const e=v.remotePlayers.get(t.playerId);e&&e.setState(st.RECOVERING)},Z.onLocalRagdollUpdate=t=>{t.position&&v.localPlayer.setRagdollState(t)},Z.onLocalRecovery=()=>{v.localPlayer.setRecovering()},Z.onLocalWalking=()=>{v.localPlayer.setWalking()}}_setupInstructions(){const t=document.createElement("div");t.style.cssText="position:fixed;bottom:20px;left:50%;transform:translateX(-50%);color:white;font-family:sans-serif;text-align:center;z-index:100;",t.innerHTML="Click to start<br>WASD to move, Mouse to look<br>Click objects to grab",document.body.appendChild(t),document.addEventListener("click",()=>{v.localPlayer.requestPointerLock(),t.style.display="none";const e=document.getElementById("crosshair");e&&(e.style.display="block")},{once:!0})}_setupResizeHandler(){window.addEventListener("resize",()=>{!v.camera||!v.renderer||(v.camera.aspect=window.innerWidth/window.innerHeight,v.camera.updateProjectionMatrix(),v.renderer.setSize(window.innerWidth,window.innerHeight))})}_animate(){requestAnimationFrame(()=>this._animate()),this.update()}update(){const t=v.clock.getDelta();v.localPlayer.update(t),v.pcGrabSystem.update(),Z.setLocalPlayerState(v.localPlayer.getState());const e=v.pcGrabSystem.getGrabbedObjectId();if(e){const i=v.pcGrabSystem.getGrabbedObjectPosition();i&&Z.sendObjectUpdate(e,i)}const s=Z.getVRHeadData();s&&v.vrHostAvatar&&v.vrHostAvatar.updateHead(s),v.remotePlayers.forEach(i=>{i.update(t)}),v.renderer.render(v.scene,v.camera)}_updateRemotePlayers(t){t.forEach((e,s)=>{if(!v.remotePlayers.has(s)){const i=new Ne(s,v.scene);v.remotePlayers.set(s,i)}v.remotePlayers.get(s).updateFromState(e)}),v.remotePlayers.forEach((e,s)=>{t.has(s)||(e.dispose(),v.remotePlayers.delete(s))})}_updateObjectsFromNetwork(t){t.forEach((e,s)=>{var n;const i=v.grabbables.find(o=>o.userData.networkId===s);i&&!(((n=v.pcGrabSystem)==null?void 0:n.getGrabbedObjectId())===s)&&e.position&&i.position.set(e.position.x,e.position.y,e.position.z)})}_createBlockMeshes(){[{id:"block_test1",pos:new V(.3,0,-.3)},{id:"block_test2",pos:new V(-.3,0,-.3)}].forEach(({id:e,pos:s})=>{const i=new zt(.08,.08,.08),n=new ft({color:16737792,roughness:.5,metalness:.3}),o=new vt(i,n);o.position.copy(s),o.userData.networkId=e,o.userData.grabbable=!0,o.castShadow=!0,o.receiveShadow=!0,v.scene.add(o),v.grabbables.push(o)})}_createCameraMesh(){const t=new Le,e=new zt(.08,.06,.1),s=new ft({color:3355443,roughness:.3,metalness:.7}),i=new vt(e,s);t.add(i);const n=new He(.025,.03,.04,16),o=new ft({color:1118481,roughness:.2,metalness:.8}),r=new vt(n,o);r.rotation.x=Math.PI/2,r.position.z=-.07,t.add(r),t.position.set(.5,.3,0),t.userData.networkId="camera_main",t.userData.grabbable=!0,v.scene.add(t),v.grabbables.push(t)}}let Y,Ae,_e,Te;function bo(){Y=new ys,Y.onHostDashboard=async()=>{try{Y.setStatus("Starting dashboard host..."),vo()}catch(w){console.error("Failed to start dashboard:",w),Y.setStatus("Failed to start: "+(w.message||"Unknown error"))}},Y.onJoinAsVR=async()=>{try{Y.setStatus("Connecting to host as VR..."),await _.joinAsVRClient(),Y.setStatus("Connected! Starting VR..."),wo()}catch(w){console.error("Failed to join as VR:",w),Y.setStatus("Failed to join: "+(w.message||"Unknown error"))}},Y.onJoinGame=async()=>{try{Y.setStatus("Connecting to host..."),await _.joinRoom(),Y.setStatus("Connected! Starting game..."),xo()}catch(w){console.error("Failed to join:",w),Y.setStatus("Failed to join: "+(w.message||"Unknown error"))}}}async function vo(){try{Ae=new Xn(Y),await Ae.start()}catch(w){console.error("Failed to start dashboard host:",w),Y.show(),Y.setStatus("Failed to start: "+(w.message||"Unknown error"))}}async function wo(){try{_e=new uo(Y),await _e.start()}catch(w){console.error("Failed to start VR client:",w),Y.show(),Y.setStatus("Failed to start VR: "+(w.message||"Unknown error"))}}function xo(){try{Te=new go(Y),Te.start()}catch(w){console.error("Failed to start client game:",w),Y.show(),Y.setStatus("Failed to start: "+(w.message||"Unknown error"))}}bo();
