import{n,M as o,S as d,C as l,l as m,g as w,c as r,d as h,A as u,D as f,q as p,W as v,f as g,B as c,m as y}from"./VRHostAvatar-CCCp73h2.js";class S{constructor(){this.scene=null,this.renderer=null,this.camera=null,this.clock=null,this.lastUpdate=0,this.isConnected=!1,this.hasReceivedCameraData=!1,this.remotePlayers=new Map,this.objectMeshes=new Map,this.vrHostAvatar=null,this.statusEl=document.getElementById("status"),this.autoConnect()}async autoConnect(){this.updateStatus("Connecting to host...","waiting");try{await n.joinRoom(),this.onConnected()}catch(t){console.error("Failed to connect:",t),this.updateStatus("No host found - retrying...","error"),setTimeout(()=>this.autoConnect(),3e3)}}onConnected(){this.updateStatus("Connected - waiting for camera data...","waiting"),this.initScene(),n.on(o.WORLD_STATE,t=>this.onWorldState(t)),n.on(o.HAND_TRACKING,t=>this.onHandTracking(t)),setInterval(()=>this.checkConnection(),1e3),this.animate()}initScene(){this.scene=new d,this.scene.background=new l(5263440),this.clock=new m;const t=new w(10,10),s=new r({color:2236962,roughness:.8}),e=new h(t,s);e.rotation.x=-Math.PI/2,e.receiveShadow=!0,this.scene.add(e);const i=new u(4210752,2);this.scene.add(i);const a=new f(16777215,2);a.position.set(1,4,2),a.castShadow=!0,this.scene.add(a),this.vrHostAvatar=new p(this.scene),this.renderer=new v({antialias:!0}),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(window.innerWidth,window.innerHeight),this.renderer.shadowMap.enabled=!0,document.body.appendChild(this.renderer.domElement),this.camera=new g(60,window.innerWidth/window.innerHeight,.01,50),this.camera.position.set(0,.3,0),window.addEventListener("resize",()=>this.onResize())}createObjectMesh(t){let s,e;if(t.startsWith("block_"))s=new c(.12,.12,.06),e=new r({color:65416});else{if(t.startsWith("camera_"))return null;s=new c(.1,.1,.1),e=new r({color:8947848})}const i=new h(s,e);return i.castShadow=!0,this.scene.add(i),this.objectMeshes.set(t,i),i}onWorldState(t){if(t.cameraTransform){const{position:s,quaternion:e,fov:i}=t.cameraTransform;this.camera.position.set(s.x,s.y,s.z),this.camera.quaternion.set(e.x,e.y,e.z,e.w),i&&i!==this.camera.fov&&(this.camera.fov=i,this.camera.updateProjectionMatrix()),this.lastUpdate=Date.now(),this.hasReceivedCameraData||(this.hasReceivedCameraData=!0,this.updateStatus("Receiving camera feed","connected"))}if(t.vrHead&&this.vrHostAvatar&&this.vrHostAvatar.updateHead(t.vrHead),t.players){const s=new Set;t.players.forEach(e=>{s.add(e.id);let i=this.remotePlayers.get(e.id);i||(i=new y(e.id,this.scene),this.remotePlayers.set(e.id,i)),i.updateFromState(e)}),this.remotePlayers.forEach((e,i)=>{s.has(i)||(e.dispose(),this.remotePlayers.delete(i))})}if(t.playerPhysics&&t.playerPhysics.forEach(s=>{const e=this.remotePlayers.get(s.id);e&&(e.updatePhysicsState(s),s.state!==void 0&&e.setState(s.state))}),t.objects){const s=new Set;t.objects.forEach(e=>{s.add(e.id);let i=this.objectMeshes.get(e.id);!i&&!e.id.startsWith("camera_")&&(i=this.createObjectMesh(e.id)),i&&e.position&&(i.position.set(e.position.x,e.position.y,e.position.z),e.rotation&&i.rotation.set(e.rotation.x||e.rotation._x||0,e.rotation.y||e.rotation._y||0,e.rotation.z||e.rotation._z||0))}),this.objectMeshes.forEach((e,i)=>{s.has(i)||(this.scene.remove(e),this.objectMeshes.delete(i))})}}onHandTracking(t){!t.hands||!this.vrHostAvatar||this.vrHostAvatar.updateHands(t.hands)}checkConnection(){const s=Date.now()-this.lastUpdate;if(this.hasReceivedCameraData&&s>2e3)this.updateStatus("Signal lost - waiting for camera...","waiting");else if(this.hasReceivedCameraData){const e=Math.min(s,999);this.updateStatus(`Live (${e}ms)`,"connected")}}updateStatus(t,s){this.statusEl.textContent=t,this.statusEl.className=s}onResize(){!this.camera||!this.renderer||(this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix(),this.renderer.setSize(window.innerWidth,window.innerHeight))}animate(){if(requestAnimationFrame(()=>this.animate()),!this.renderer||!this.scene||!this.camera)return;const t=this.clock.getDelta();this.remotePlayers.forEach(s=>{s.update(t)}),this.renderer.render(this.scene,this.camera)}}new S;
